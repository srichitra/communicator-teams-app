"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Recognizer = void 0;
const configurable_1 = require("./configurable");
const omit_1 = __importDefault(require("lodash/omit"));
const recognizerResult_1 = require("./recognizerResult");
/**
 * Recognizer base class.
 */
class Recognizer extends configurable_1.Configurable {
    /**
       * To recognize intents and entities in a users utterance.
       *
       * @param {DialogContext} _dialogContext Dialog Context.
       * @param {Partial<Activity>} _activity Activity.
       * @param {Record<string, string>} _telemetryProperties Additional properties to be logged to telemetry with event.
       * @param {Record<string, number>} _telemetryMetrics Additional metrics to be logged to telemetry with event.
       */
    recognize(_dialogContext, _activity, _telemetryProperties, _telemetryMetrics) {
        throw new Error('Please implement recognize function.');
    }
    /**
       * Creates choose intent result in the case that there are conflicting or ambiguous signals from the recognizers.
       *
       * @param {Record<string, RecognizerResult>} recognizerResults A group of recognizer results.
       * @returns {RecognizerResult} Recognizer result which is ChooseIntent.
       */
    createChooseIntentResult(recognizerResults) {
        let text = '';
        let sentiment = {};
        const candidates = Object.entries(recognizerResults).reduce((candidates, [key, result]) => {
            text = result.text;
            sentiment = result.sentiment;
            const { intent, score } = (0, recognizerResult_1.getTopScoringIntent)(result);
            if (intent !== 'None') {
                candidates.push({
                    id: key,
                    intent,
                    score,
                    result,
                });
            }
            return candidates;
        }, []);
        if (candidates.length) {
            const recognizerResult = {
                text,
                intents: { ChooseIntent: { score: 1.0 } },
                candidates,
                entities: {},
            };
            return recognizerResult;
        }
        // just return a `None` intent.
        const recognizerResult = {
            text,
            intents: { None: { score: 1.0 } },
            entities: {},
            sentiment,
        };
        return recognizerResult;
    }
    /**
       * Uses the RecognizerResult to create a list of properties to be included when tracking the result in telemetry.
       *
       * @param {RecognizerResult} recognizerResult Recognizer Result.
       * @param {Record<string, string>} telemetryProperties A list of properties to append or override the properties created using the RecognizerResult.
       * @param {DialogContext} _dialogContext Dialog Context.
       * @returns {Record<string, string>} A collection of properties that can be included when calling the TrackEvent method on the TelemetryClient.
       */
    fillRecognizerResultTelemetryProperties(recognizerResult, telemetryProperties, _dialogContext) {
        var _a;
        const { intent, score } = (0, recognizerResult_1.getTopScoringIntent)(recognizerResult);
        const intents = Object.entries(recognizerResult.intents);
        const properties = {
            Text: recognizerResult.text,
            AlteredText: (_a = recognizerResult.alteredText) !== null && _a !== void 0 ? _a : '',
            TopIntent: intents.length > 0 ? intent : '',
            TopIntentScore: intents.length > 0 ? score.toString() : '',
            Intents: intents.length > 0 ? JSON.stringify(recognizerResult.intents) : '',
            Entities: recognizerResult.entities ? JSON.stringify(recognizerResult.entities) : '',
            AdditionalProperties: JSON.stringify((0, omit_1.default)(recognizerResult, ['text', 'alteredText', 'intents', 'entities'])),
        };
        if (telemetryProperties) {
            return Object.assign({}, properties, telemetryProperties);
        }
        return properties;
    }
    stringifyAdditionalPropertiesOfRecognizerResult(recognizerResult) {
        const generalProperties = new Set(['text', 'alteredText', 'intents', 'entities']);
        const additionalProperties = {};
        for (const key in recognizerResult) {
            if (!generalProperties.has(key)) {
                additionalProperties[key] = recognizerResult[key];
            }
        }
        return Object.keys(additionalProperties).length > 0 ? JSON.stringify(additionalProperties) : '';
    }
}
exports.Recognizer = Recognizer;
//# sourceMappingURL=recognizer.js.map