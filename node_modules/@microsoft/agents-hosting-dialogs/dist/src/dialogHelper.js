"use strict";
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.runDialog = runDialog;
exports.internalRun = internalRun;
exports.getActiveDialogContext = getActiveDialogContext;
const dialogEvents_1 = require("./dialogEvents");
const dialogSet_1 = require("./dialogSet");
const memory_1 = require("./memory");
const dialogTurnStatus_1 = require("./dialogTurnStatus");
const agents_activity_1 = require("@microsoft/agents-activity");
/**
 * Runs a dialog from a given context and accessor.
 *
 * @param dialog The Dialog to run.
 * @param context TurnContext object for the current turn of conversation with the user.
 * @param accessor Defined methods for accessing the state property created in a State object.
 */
async function runDialog(dialog, context, accessor) {
    if (!dialog) {
        throw new Error('runDialog(): missing dialog');
    }
    if (!context) {
        throw new Error('runDialog(): missing context');
    }
    if (!context.activity) {
        throw new Error('runDialog(): missing context.activity');
    }
    if (!accessor) {
        throw new Error('runDialog(): missing accessor');
    }
    const dialogSet = new dialogSet_1.DialogSet(accessor);
    dialogSet.add(dialog);
    const dialogContext = await dialogSet.createContext(context);
    await internalRun(context, dialog.id, dialogContext);
}
/**
 * @param context The TurnContext for the turn.
 * @param dialogId The dialog ID.
 * @param dialogContext The DialogContext for the current turn of conversation.
 * @param dialogStateManagerConfiguration Configuration for the dialog state manager.
 * @returns {Promise<DialogTurnResult>} a promise resolving to the dialog turn result.
 */
async function internalRun(context, dialogId, dialogContext, dialogStateManagerConfiguration) {
    // map TurnState into root dialog context.services
    context.turnState.forEach((service, key) => {
        dialogContext.services.push(key, service);
    });
    const dialogStateManager = new memory_1.DialogStateManager(dialogContext, dialogStateManagerConfiguration);
    await dialogStateManager.loadAllScopes();
    dialogContext.context.turnState.push('DialogStateManager', dialogStateManager);
    let dialogTurnResult = null;
    // Loop as long as we are getting valid OnError handled we should continue executing the actions for the turn.
    // NOTE: We loop around this block because each pass through we either complete the turn and break out of the loop
    // or we have had an exception AND there was an OnError action which captured the error. We need to continue the
    // turn based on the actions the OnError handler introduced.
    let endOfTurn = false;
    while (!endOfTurn) {
        try {
            dialogTurnResult = await innerRun(context, dialogId, dialogContext);
            // turn successfully completed, break the loop
            endOfTurn = true;
        }
        catch (err) {
            // fire error event, bubbling from the leaf.
            const handled = await dialogContext.emitEvent(dialogEvents_1.DialogEvents.error, err, true, true);
            if (!handled) {
                // error was NOT handled, throw the exception and end the turn.
                // (This will trigger the Adapter.OnError handler and end the entire dialog stack)
                throw err;
            }
        }
    }
    // save all state scopes to their respective agentState locations.
    await dialogStateManager.saveAllChanges();
    // return the redundant result because the DialogManager contract expects it
    return dialogTurnResult;
}
async function innerRun(context, dialogId, dialogContext) {
    // Continue or start the dialog.
    let result = await dialogContext.continueDialog();
    if (result.status === dialogTurnStatus_1.DialogTurnStatus.empty) {
        result = await dialogContext.beginDialog(dialogId);
    }
    await sendStateSnapshotTrace(dialogContext);
    return result;
}
/**
 * Recursively walk up the dialog context stack to find the active DC.
 *
 * @param dialogContext DialogContext for the current turn of conversation with the user.
 * @returns Active DialogContext.
 */
function getActiveDialogContext(dialogContext) {
    const child = dialogContext.child;
    if (!child) {
        return dialogContext;
    }
    return getActiveDialogContext(child);
}
// Helper to send a trace activity with a memory snapshot of the active dialog DC.
const sendStateSnapshotTrace = async (dialogContext) => {
    const traceLabel = 'Agent State';
    // Send trace of memory
    const snapshot = getActiveDialogContext(dialogContext).state.getMemorySnapshot();
    const traceActivity = new agents_activity_1.Activity(agents_activity_1.ActivityTypes.Trace);
    traceActivity.name = 'AgentState';
    traceActivity.label = 'https://www.botframework.com/schemas/botState';
    traceActivity.value = snapshot;
    traceActivity.label = traceLabel;
    await dialogContext.context.sendActivity(traceActivity);
};
//# sourceMappingURL=dialogHelper.js.map