"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChoiceFactory = void 0;
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const agents_activity_1 = require("@microsoft/agents-activity");
const agents_hosting_1 = require("@microsoft/agents-hosting");
/**
 * A set of utility functions to assist with the formatting a 'message' activity containing a list
 * of choices.
 *
 */
class ChoiceFactory {
    /**
       * Returns a 'message' activity containing a list of choices that has been automatically
       * formatted based on the capabilities of a given channel.
       *
       * @param channelOrContext Channel ID or context object for the current turn of conversation.
       * @param choices List of choices to render.
       * @param text (Optional) text of the message.
       * @param speak (Optional) SSML to speak for the message.
       * @param options (Optional) formatting options to use when rendering as a list.
       * @returns The created message activity.
       */
    static forChannel(channelOrContext, choices, text, speak, options) {
        const list = ChoiceFactory.toChoices(choices);
        let maxTitleLength = 0;
        list.forEach((choice) => {
            const l = choice.action && choice.action.title ? choice.action.title.length : choice.value.length;
            if (l > maxTitleLength) {
                maxTitleLength = l;
            }
        });
        const longTitles = maxTitleLength > this.MAX_ACTION_TITLE_LENGTH;
        if (!longTitles && choices.length <= 3) {
            // If the titles are short and there are 3 or less choices we'll use an inline list.
            return ChoiceFactory.inline(list, text, speak, options);
        }
        else {
            return ChoiceFactory.list(list, text, speak, options);
        }
    }
    /**
       * Returns a 'message' activity containing a list of choices that has been formatted as an
       * inline list.
       *
       * @param choices List of choices to render.
       * @param text (Optional) text of the message.
       * @param speak (Optional) SSML to speak for the message.
       * @param options (Optional) formatting options to tweak rendering of list.
       * @returns The created message activity.
       */
    static inline(choices, text, speak, options) {
        const opt = {
            inlineSeparator: ', ',
            inlineOr: ' or ',
            inlineOrMore: ', or ',
            includeNumbers: true,
            ...options,
        };
        let connector = '';
        let txt = text || '';
        txt += ' ';
        ChoiceFactory.toChoices(choices).forEach((choice, index) => {
            const title = choice.action && choice.action.title ? choice.action.title : choice.value;
            txt += `${connector}${opt.includeNumbers ? '(' + (index + 1).toString() + ') ' : ''}${title}`;
            if (index === choices.length - 2) {
                connector = (index === 0 ? opt.inlineOr : opt.inlineOrMore) || '';
            }
            else {
                connector = opt.inlineSeparator || '';
            }
        });
        txt += '';
        return agents_hosting_1.MessageFactory.text(txt, speak, agents_activity_1.InputHints.ExpectingInput);
    }
    /**
       * Returns a 'message' activity containing a list of choices that has been formatted as an
       * numbered or bulleted list.
       *
       * @param choices List of choices to render.
       * @param text (Optional) text of the message.
       * @param speak (Optional) SSML to speak for the message.
       * @param options (Optional) formatting options to tweak rendering of list.
       * @returns The created message activity.
       */
    static list(choices, text, speak, options) {
        const opt = {
            includeNumbers: true,
            ...options,
        };
        let connector = '';
        let txt = text || '';
        txt += '\n\n   ';
        ChoiceFactory.toChoices(choices).forEach((choice, index) => {
            const title = choice.action && choice.action.title ? choice.action.title : choice.value;
            txt += `${connector}${opt.includeNumbers ? (index + 1).toString() + '. ' : '- '}${title}`;
            connector = '\n   ';
        });
        return agents_hosting_1.MessageFactory.text(txt, speak, agents_activity_1.InputHints.ExpectingInput);
    }
    /**
       * Takes a mixed list of `string` and `Choice` based choices and returns them as a `Choice[]`.
       *
       * @param choices List of choices to add.
       * @returns A list of choices.
       */
    static toChoices(choices) {
        return (choices || [])
            .map((choice) => (typeof choice === 'string' ? { value: choice } : choice))
            .map((choice) => {
            const action = choice.action;
            if (action) {
                action.type = action.type ? action.type : agents_activity_1.ActionTypes.ImBack;
                if (!action.value && action.title) {
                    action.value = action.title;
                }
                else if (!action.title && action.value) {
                    action.title = action.value;
                }
                else if (!action.title && !action.value) {
                    action.title = action.value = choice.value;
                }
            }
            return choice;
        })
            .filter((choice) => choice);
    }
}
exports.ChoiceFactory = ChoiceFactory;
ChoiceFactory.MAX_ACTION_TITLE_LENGTH = 20;
//# sourceMappingURL=choiceFactory.js.map