"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findValues = findValues;
const tokenizer_1 = require("./tokenizer");
/**
 * INTERNAL: Low-level function that searches for a set of values within an utterance. Higher level
 * functions like `findChoices()` and `recognizeChoices()` are layered above this function.  In most
 * cases its easier to just call one of the higher level functions instead but this function contains
 * the fuzzy search algorithm that drives choice recognition.
 *
 * @param utterance The text or user utterance to search over.
 * @param values List of values to search over.
 * @param options (Optional) options used to tweak the search that's performed.
 * @returns A list of found values.
 */
function findValues(utterance, values, options) {
    function indexOfToken(token, startPos) {
        for (let i = startPos; i < tokens.length; i++) {
            if (tokens[i].normalized === token.normalized) {
                return i;
            }
        }
        return -1;
    }
    function findExactMatch(utterance, values) {
        const entry = values.find(({ value }) => value.toLowerCase() === utterance.toLowerCase());
        if (!entry) {
            return null;
        }
        return {
            text: utterance,
            start: 0,
            end: utterance.length - 1,
            typeName: 'value',
            resolution: {
                value: entry.value,
                index: entry.index,
                score: 1,
            },
        };
    }
    const exactMatch = findExactMatch(utterance, values);
    if (exactMatch) {
        return [exactMatch];
    }
    function matchValue(index, value, vTokens, startPos) {
        let matched = 0;
        let totalDeviation = 0;
        let start = -1;
        let end = -1;
        vTokens.forEach((token) => {
            const pos = indexOfToken(token, startPos);
            if (pos >= 0) {
                const distance = matched > 0 ? pos - startPos : 0;
                if (distance <= maxDistance) {
                    matched++;
                    totalDeviation += distance;
                    startPos = pos + 1;
                    if (start < 0) {
                        start = pos;
                    }
                    end = pos;
                }
            }
        });
        let result;
        if (matched > 0 && (matched === vTokens.length || opt.allowPartialMatches)) {
            const completeness = matched / vTokens.length;
            const accuracy = matched / (matched + totalDeviation);
            const score = completeness * accuracy;
            result = {
                start,
                end,
                typeName: 'value',
                resolution: {
                    value,
                    index,
                    score,
                },
            };
        }
        return result;
    }
    const list = values.sort((a, b) => b.value.length - a.value.length);
    let matches = [];
    const opt = options || {};
    const tokenizer = opt.tokenizer || tokenizer_1.defaultTokenizer;
    const tokens = tokenizer(utterance, opt.locale);
    const maxDistance = opt.maxTokenDistance !== undefined ? opt.maxTokenDistance : 2;
    list.forEach((entry) => {
        let startPos = 0;
        const vTokens = tokenizer(entry.value.trim(), opt.locale);
        while (startPos < tokens.length) {
            const match = matchValue(entry.index, entry.value, vTokens, startPos);
            if (match) {
                startPos = match.end + 1;
                matches.push(match);
            }
            else {
                break;
            }
        }
    });
    matches = matches.sort((a, b) => b.resolution.score - a.resolution.score);
    const results = [];
    const foundIndexes = {};
    const usedTokens = {};
    matches.forEach((match) => {
        let add = !Object.prototype.hasOwnProperty.call(foundIndexes, match.resolution.index);
        for (let i = match.start; i <= match.end; i++) {
            if (usedTokens[i]) {
                add = false;
                break;
            }
        }
        if (add) {
            foundIndexes[match.resolution.index] = true;
            for (let i = match.start; i <= match.end; i++) {
                usedTokens[i] = true;
            }
            match.start = tokens[match.start].start;
            match.end = tokens[match.end].end;
            match.text = utterance.substring(match.start, match.end + 1);
            results.push(match);
        }
    });
    return results.sort((a, b) => a.start - b.start);
}
//# sourceMappingURL=findValues.js.map