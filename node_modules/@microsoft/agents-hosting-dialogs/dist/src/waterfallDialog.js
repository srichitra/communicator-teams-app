"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WaterfallDialog = void 0;
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const uuid_1 = require("uuid");
const agents_activity_1 = require("@microsoft/agents-activity");
const dialog_1 = require("./dialog");
const waterfallStepContext_1 = require("./waterfallStepContext");
const dialogReason_1 = require("./dialogReason");
/**
 * A waterfall is a dialog that's optimized for prompting a user with a series of questions.
 *
 */
class WaterfallDialog extends dialog_1.Dialog {
    /**
       * Creates a new waterfall dialog containing the given array of steps.
       *
       * @remarks
       * See the addstep function for details on creating a valid step function.
       * @param dialogId Unique ID of the dialog within the component or set its being added to.
       * @param steps (Optional) array of asynchronous waterfall step functions.
       */
    constructor(dialogId, steps) {
        super(dialogId);
        this.steps = [];
        if (steps) {
            this.steps = steps.slice(0);
        }
    }
    /**
       * Gets the dialog version, composed of the ID and number of steps.
       *
       * @returns Dialog version, composed of the ID and number of steps.
       */
    getVersion() {
        // Simply return the id + number of steps to help detect when new steps have
        // been added to a given waterfall.
        return `${this.id}:${this.steps.length}`;
    }
    /**
       * Adds a new step to the waterfall.
       *
       * @param step Asynchronous step function to call.
       * @returns Waterfall dialog for fluent calls to `addStep()`.
       */
    addStep(step) {
        this.steps.push(step);
        return this;
    }
    /**
       * Called when the WaterfallDialog is started and pushed onto the dialog stack.
       *
       * @param dialogContext The DialogContext for the current turn of conversation.
       * @param options Optional, initial information to pass to the Dialog.
       * @returns A Promise representing the asynchronous operation.
       * @remarks
       * If the task is successful, the result indicates whether the Dialog is still
       * active after the turn has been processed by the dialog.
       */
    async beginDialog(dialogContext, options) {
        const state = dialogContext.activeDialog.state;
        state.options = options || {};
        state.values = {
            instanceId: (0, uuid_1.v4)(),
        };
        // Run the first step
        return await this.runStep(dialogContext, 0, dialogReason_1.DialogReason.beginCalled);
    }
    /**
       * Called when the WaterfallDialog is _continued_, where it is the active dialog and the
       * user replies with a new Activity.
       *
       * @param dialogContext The DialogContext for the current turn of conversation.
       * @returns A Promise representing the asynchronous operation.
       * @remarks
       * If the task is successful, the result indicates whether the dialog is still
       * active after the turn has been processed by the dialog. The result may also contain a
       * return value.
       */
    async continueDialog(dialogContext) {
        // Don't do anything for non-message activities
        if (dialogContext.context.activity.type !== agents_activity_1.ActivityTypes.Message) {
            return dialog_1.Dialog.EndOfTurn;
        }
        // Run next step with the message text as the result.
        return await this.resumeDialog(dialogContext, dialogReason_1.DialogReason.continueCalled, dialogContext.context.activity.text);
    }
    /**
       * Called when a child WaterfallDialog completed its turn, returning control to this dialog.
       *
       * @param dc The DialogContext for the current turn of the conversation.
       * @param reason DialogReason why the dialog resumed.
       * @param result Optional, value returned from the dialog that was called. The type
       * of the value returned is dependent on the child dialog.
       * @returns A Promise representing the asynchronous operation.
       */
    async resumeDialog(dc, reason, result) {
        // Increment step index and run step
        const state = dc.activeDialog.state;
        return await this.runStep(dc, state.stepIndex + 1, reason, result);
    }
    /**
       * Called when an individual waterfall step is being executed.
       *
       * @remarks
       * SHOULD be overridden by derived class that want to add custom logging semantics.
       *
       * @param step Context object for the waterfall step to execute.
       * @returns A promise with the DialogTurnResult.
       */
    async onStep(step) {
        return await this.steps[step.index](step);
    }
    /**
       * Executes a step of the WaterfallDialog.
       *
       * @param dc The DialogContext for the current turn of conversation.
       * @param index The index of the current waterfall step to execute.
       * @param reason The DialogReason the waterfall step is being executed.
       * @param result Optional, result returned by a dialog called in the previous waterfall step.
       * @returns A Promise that represents the work queued to execute.
       */
    async runStep(dc, index, reason, result) {
        if (index < this.steps.length) {
            // Update persisted step index
            const state = dc.activeDialog.state;
            state.stepIndex = index;
            // Create step context
            let nextCalled = false;
            const step = new waterfallStepContext_1.WaterfallStepContext(dc, {
                index,
                options: state.options,
                reason,
                result,
                values: state.values,
                onNext: async (stepResult) => {
                    if (nextCalled) {
                        throw new Error(`WaterfallStepContext.next(): method already called for dialog and step '${this.id}[${index}]'.`);
                    }
                    nextCalled = true;
                    return await this.resumeDialog(dc, dialogReason_1.DialogReason.nextCalled, stepResult);
                },
            });
            // Execute step
            return await this.onStep(step);
        }
        else {
            // End of waterfall so just return to parent
            return await dc.endDialog(result);
        }
    }
    /**
       * Identifies the step name by its position index.
       *
       * @param index Step position
       * @returns A string that identifies the step name.
       */
    waterfallStepName(index) {
        // Log Waterfall Step event. Each event has a distinct name to hook up
        // to the Application Insights funnel.
        let stepName = '';
        if (this.steps[index]) {
            try {
                stepName = this.steps[index].name;
            }
            finally {
                if (stepName === undefined || stepName === '') {
                    stepName = 'Step' + (index + 1) + 'of' + this.steps.length;
                }
            }
        }
        return stepName;
    }
}
exports.WaterfallDialog = WaterfallDialog;
//# sourceMappingURL=waterfallDialog.js.map