"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AgentStateMemoryScope = void 0;
const memoryScope_1 = require("./memoryScope");
/**
 * Base class for memory scopes based on AgentState.
 */
class AgentStateMemoryScope extends memoryScope_1.MemoryScope {
    /**
       * Initializes a new instance of the AgentStateMemoryScope class.
       *
       * @param name name of the property.
       */
    constructor(name) {
        super(name, true);
    }
    /**
       * Get the backing memory for this scope.
       *
       * @param dialogContext current dialog context.
       * @returns Memory for the scope.
       */
    getMemory(dialogContext) {
        const agentState = dialogContext.context.turnState.get(this.stateKey);
        if (agentState) {
            return agentState.get(dialogContext.context);
        }
        return undefined;
    }
    /**
       * Changes the backing object for the memory scope.
       *
       * @param dialogContext current dialog context
       * @param _memory memory
       */
    setMemory(dialogContext, _memory) {
        const agentState = dialogContext.context.turnState.get(this.stateKey);
        if (!agentState) {
            throw new Error(`${this.stateKey} is not available.`);
        }
        throw new Error('You cannot replace the root AgentState object.');
    }
    /**
       * Populates the state cache for this AgentState from the storage layer.
       *
       * @param dialogContext The DialogContext object for this turn.
       * @param force Optional, `true` to overwrite any existing state cache;
       * or `false` to load state from storage only if the cache doesn't already exist.
       * @returns A Promise that represents the work queued to execute.
       */
    async load(dialogContext, force = false) {
        const agentState = dialogContext.context.turnState.get(this.stateKey);
        if (agentState) {
            await agentState.load(dialogContext.context, force);
        }
    }
    /**
       * Writes the state cache for this AgentState to the storage layer.
       *
       * @param dialogContext The DialogContext object for this turn.
       * @param force Optional, `true` to save the state cache to storage;
       * or `false` to save state to storage only if a property in the cache has changed.
       * @returns A Promise that represents the work queued to execute.
       */
    async saveChanges(dialogContext, force = false) {
        const agentState = dialogContext.context.turnState.get(this.stateKey);
        if (agentState) {
            await agentState.saveChanges(dialogContext.context, force);
        }
    }
    /**
       * Deletes any state in storage and the cache for this AgentState.
       *
       * @param _dialogContext The DialogContext object for this turn.
       * @returns A Promise that represents the work queued to execute.
       */
    async delete(_dialogContext) {
        return Promise.resolve();
    }
}
exports.AgentStateMemoryScope = AgentStateMemoryScope;
//# sourceMappingURL=agentStateMemoryScope.js.map