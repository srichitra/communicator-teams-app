"use strict";
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeamsActivityHandler = void 0;
const readReceipInfo_1 = require("./message-read-info/readReceipInfo");
const z = __importStar(require("zod"));
const agents_hosting_1 = require("@microsoft/agents-hosting");
const agents_activity_1 = require("@microsoft/agents-activity");
const activityValueParsers_1 = require("./parsers/activityValueParsers");
const teamsChannelDataParser_1 = require("./parsers/teamsChannelDataParser");
const teamsConnectorClient_1 = require("./connector-client/teamsConnectorClient");
const TeamsMeetingStartT = z
    .object({
    Id: z.string(),
    JoinUrl: z.string(),
    MeetingType: z.string(),
    Title: z.string(),
    StartTime: z.string()
});
const TeamsMeetingEndT = z
    .object({
    Id: z.string(),
    JoinUrl: z.string(),
    MeetingType: z.string(),
    Title: z.string(),
    EndTime: z.string()
});
class TeamsActivityHandler extends agents_hosting_1.ActivityHandler {
    /**
     * Handles invoke activities.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<InvokeResponse>} The invoke response.
     */
    async onInvokeActivity(context) {
        let runEvents = true;
        try {
            if (!context.activity.name && context.activity.channelId === 'msteams') {
                return await this.handleTeamsCardActionInvoke(context);
            }
            else {
                switch (context.activity.name) {
                    case 'config/fetch':
                        return agents_hosting_1.ActivityHandler.createInvokeResponse(await this.handleTeamsConfigFetch(context, context.activity.value));
                    case 'config/submit':
                        return agents_hosting_1.ActivityHandler.createInvokeResponse(await this.handleTeamsConfigSubmit(context, context.activity.value));
                    case 'fileConsent/invoke':
                        return agents_hosting_1.ActivityHandler.createInvokeResponse(await this.handleTeamsFileConsent(context, context.activity.value));
                    case 'actionableMessage/executeAction':
                        await this.handleTeamsO365ConnectorCardAction(context, context.activity.value);
                        return agents_hosting_1.ActivityHandler.createInvokeResponse();
                    case 'composeExtension/queryLink':
                        return agents_hosting_1.ActivityHandler.createInvokeResponse(await this.handleTeamsAppBasedLinkQuery(context, context.activity.value));
                    case 'composeExtension/anonymousQueryLink':
                        return agents_hosting_1.ActivityHandler.createInvokeResponse(await this.handleTeamsAnonymousAppBasedLinkQuery(context, context.activity.value));
                    case 'composeExtension/query':
                        return agents_hosting_1.ActivityHandler.createInvokeResponse(await this.handleTeamsMessagingExtensionQuery(context, (0, activityValueParsers_1.parseValueMessagingExtensionQuery)(context.activity.value)));
                    case 'composeExtension/selectItem':
                        return agents_hosting_1.ActivityHandler.createInvokeResponse(await this.handleTeamsMessagingExtensionSelectItem(context, context.activity.value));
                    case 'composeExtension/submitAction':
                        return agents_hosting_1.ActivityHandler.createInvokeResponse(await this.handleTeamsMessagingExtensionSubmitActionDispatch(context, context.activity.value));
                    case 'composeExtension/fetchTask':
                        return agents_hosting_1.ActivityHandler.createInvokeResponse(await this.handleTeamsMessagingExtensionFetchTask(context, context.activity.value));
                    case 'composeExtension/querySettingUrl':
                        return agents_hosting_1.ActivityHandler.createInvokeResponse(await this.handleTeamsMessagingExtensionConfigurationQuerySettingUrl(context, context.activity.value));
                    case 'composeExtension/setting':
                        await this.handleTeamsMessagingExtensionConfigurationSetting(context, context.activity.value);
                        return agents_hosting_1.ActivityHandler.createInvokeResponse();
                    case 'composeExtension/onCardButtonClicked':
                        await this.handleTeamsMessagingExtensionCardButtonClicked(context, context.activity.value);
                        return agents_hosting_1.ActivityHandler.createInvokeResponse();
                    case 'task/fetch':
                        return agents_hosting_1.ActivityHandler.createInvokeResponse(await this.handleTeamsTaskModuleFetch(context, context.activity.value));
                    case 'task/submit':
                        return agents_hosting_1.ActivityHandler.createInvokeResponse(await this.handleTeamsTaskModuleSubmit(context, context.activity.value));
                    case 'tab/fetch':
                        return agents_hosting_1.ActivityHandler.createInvokeResponse(await this.handleTeamsTabFetch(context, context.activity.value));
                    case 'tab/submit':
                        return agents_hosting_1.ActivityHandler.createInvokeResponse(await this.handleTeamsTabSubmit(context, context.activity.value));
                    default:
                        runEvents = false;
                        return await super.onInvokeActivity(context);
                }
            }
        }
        catch (err) {
            if (err.message === 'NotImplemented') {
                return { status: 501 };
            }
            else if (err.message === 'BadRequest') {
                return { status: 400 };
            }
            throw err;
        }
        finally {
            if (runEvents) {
                this.defaultNextEvent(context)();
            }
        }
    }
    /**
     * Handles card action invoke.
     * @param {TurnContext} _context - The context object for the turn.
     * @returns {Promise<InvokeResponse>} The invoke response.
     */
    async handleTeamsCardActionInvoke(_context) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles config fetch.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {any} _configData - The config data.
     * @returns {Promise<ConfigResponse>} The config response.
     */
    async handleTeamsConfigFetch(_context, _configData) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles config submit.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {any} _configData - The config data.
     * @returns {Promise<ConfigResponse>} The config response.
     */
    async handleTeamsConfigSubmit(_context, _configData) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles file consent.
     * @param {TurnContext} context - The context object for the turn.
     * @param {FileConsentCardResponse} fileConsentCardResponse - The file consent card response.
     * @returns {Promise<void>}
     */
    async handleTeamsFileConsent(context, fileConsentCardResponse) {
        switch (fileConsentCardResponse.action) {
            case 'accept':
                return await this.handleTeamsFileConsentAccept(context, fileConsentCardResponse);
            case 'decline':
                return await this.handleTeamsFileConsentDecline(context, fileConsentCardResponse);
            default:
                throw new Error('BadRequest');
        }
    }
    /**
     * Handles file consent accept.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {FileConsentCardResponse} _fileConsentCardResponse - The file consent card response.
     * @returns {Promise<void>}
     */
    async handleTeamsFileConsentAccept(_context, _fileConsentCardResponse) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles file consent decline.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {FileConsentCardResponse} _fileConsentCardResponse - The file consent card response.
     * @returns {Promise<void>}
     */
    async handleTeamsFileConsentDecline(_context, _fileConsentCardResponse) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles O365 connector card action.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {O365ConnectorCardActionQuery} _query - The O365 connector card action query.
     * @returns {Promise<void>}
     */
    async handleTeamsO365ConnectorCardAction(_context, _query) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles sign-in verify state.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {SigninStateVerificationQuery} _query - The sign-in state verification query.
     * @returns {Promise<void>}
     */
    async handleTeamsSigninVerifyState(_context, _query) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles sign-in token exchange.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {SigninStateVerificationQuery} _query - The sign-in state verification query.
     * @returns {Promise<void>}
     */
    async handleTeamsSigninTokenExchange(_context, _query) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles messaging extension card button clicked.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {any} _cardData - The card data.
     * @returns {Promise<void>}
     */
    async handleTeamsMessagingExtensionCardButtonClicked(_context, _cardData) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles task module fetch.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {TaskModuleRequest} _taskModuleRequest - The task module request.
     * @returns {Promise<TaskModuleResponse>} The task module response.
     */
    async handleTeamsTaskModuleFetch(_context, _taskModuleRequest) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles task module submit.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {TaskModuleRequest} _taskModuleRequest - The task module request.
     * @returns {Promise<TaskModuleResponse>} The task module response.
     */
    async handleTeamsTaskModuleSubmit(_context, _taskModuleRequest) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles tab fetch.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {TabRequest} _tabRequest - The tab request.
     * @returns {Promise<TabResponse>} The tab response.
     */
    async handleTeamsTabFetch(_context, _tabRequest) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles tab submit.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {TabSubmit} _tabSubmit - The tab submit.
     * @returns {Promise<TabResponse>} The tab response.
     */
    async handleTeamsTabSubmit(_context, _tabSubmit) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles app-based link query.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {AppBasedLinkQuery} _query - The app-based link query.
     * @returns {Promise<MessagingExtensionResponse>} The messaging extension response.
     */
    async handleTeamsAppBasedLinkQuery(_context, _query) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles anonymous app-based link query.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {AppBasedLinkQuery} _query - The app-based link query.
     * @returns {Promise<MessagingExtensionResponse>} The messaging extension response.
     */
    async handleTeamsAnonymousAppBasedLinkQuery(_context, _query) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles messaging extension query.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {MessagingExtensionQuery} _query - The messaging extension query.
     * @returns {Promise<MessagingExtensionResponse>} The messaging extension response.
     */
    async handleTeamsMessagingExtensionQuery(_context, _query) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles messaging extension select item.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {any} _query - The query.
     * @returns {Promise<MessagingExtensionResponse>} The messaging extension response.
     */
    async handleTeamsMessagingExtensionSelectItem(_context, _query) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles messaging extension submit action dispatch.
     * @param {TurnContext} context - The context object for the turn.
     * @param {MessagingExtensionAction} action - The messaging extension action.
     * @returns {Promise<MessagingExtensionActionResponse>} The messaging extension action response.
     */
    async handleTeamsMessagingExtensionSubmitActionDispatch(context, action) {
        if (action.messagePreviewAction) {
            switch (action.messagePreviewAction) {
                case 'edit':
                    return await this.handleTeamsMessagingExtensionMessagePreviewEdit(context, action);
                case 'send':
                    return await this.handleTeamsMessagingExtensionMessagePreviewSend(context, action);
                default:
                    throw new Error('BadRequest');
            }
        }
        else {
            return await this.handleTeamsMessagingExtensionSubmitAction(context, action);
        }
    }
    /**
     * Handles messaging extension submit action.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {MessagingExtensionAction} _action - The messaging extension action.
     * @returns {Promise<MessagingExtensionActionResponse>} The messaging extension action response.
     */
    async handleTeamsMessagingExtensionSubmitAction(_context, _action) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles messaging extension message preview edit.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {MessagingExtensionAction} _action - The messaging extension action.
     * @returns {Promise<MessagingExtensionActionResponse>} The messaging extension action response.
     */
    async handleTeamsMessagingExtensionMessagePreviewEdit(_context, _action) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles messaging extension message preview send.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {MessagingExtensionAction} _action - The messaging extension action.
     * @returns {Promise<MessagingExtensionActionResponse>} The messaging extension action response.
     */
    async handleTeamsMessagingExtensionMessagePreviewSend(_context, _action) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles messaging extension fetch task.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {MessagingExtensionAction} _action - The messaging extension action.
     * @returns {Promise<MessagingExtensionActionResponse>} The messaging extension action response.
     */
    async handleTeamsMessagingExtensionFetchTask(_context, _action) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles messaging extension configuration query setting URL.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {MessagingExtensionQuery} _query - The messaging extension query.
     * @returns {Promise<MessagingExtensionResponse>} The messaging extension response.
     */
    async handleTeamsMessagingExtensionConfigurationQuerySettingUrl(_context, _query) {
        throw new Error('NotImplemented');
    }
    /**
     * Handles messaging extension configuration setting.
     * @param {TurnContext} _context - The context object for the turn.
     * @param {any} _settings - The settings.
     * @returns {Promise<void>}
     */
    async handleTeamsMessagingExtensionConfigurationSetting(_context, _settings) {
        throw new Error('NotImplemented');
    }
    /**
     * Dispatches conversation update activity.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async dispatchConversationUpdateActivity(context) {
        if (context.activity.channelId === 'msteams') {
            const channelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
            if ((context.activity.membersAdded != null) && context.activity.membersAdded.length > 0) {
                return await this.onTeamsMembersAdded(context);
            }
            if ((context.activity.membersRemoved != null) && context.activity.membersRemoved.length > 0) {
                return await this.onTeamsMembersRemoved(context);
            }
            if (!channelData || !channelData.eventType) {
                return await super.dispatchConversationUpdateActivity(context);
            }
            switch (channelData.eventType) {
                case 'channelCreated':
                    return await this.onTeamsChannelCreated(context);
                case 'channelDeleted':
                    return await this.onTeamsChannelDeleted(context);
                case 'channelRenamed':
                    return await this.onTeamsChannelRenamed(context);
                case 'teamArchived':
                    return await this.onTeamsTeamArchived(context);
                case 'teamDeleted':
                    return await this.onTeamsTeamDeleted(context);
                case 'teamHardDeleted':
                    return await this.onTeamsTeamHardDeleted(context);
                case 'channelRestored':
                    return await this.onTeamsChannelRestored(context);
                case 'teamRenamed':
                    return await this.onTeamsTeamRenamed(context);
                case 'teamRestored':
                    return await this.onTeamsTeamRestored(context);
                case 'teamUnarchived':
                    return await this.onTeamsTeamUnarchived(context);
                default:
                    return await super.dispatchConversationUpdateActivity(context);
            }
        }
        else {
            return await super.dispatchConversationUpdateActivity(context);
        }
    }
    /**
     * Dispatches message update activity.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async dispatchMessageUpdateActivity(context) {
        if (context.activity.channelId === 'msteams') {
            const channelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
            switch (channelData.eventType) {
                case 'undeleteMessage':
                    return await this.onTeamsMessageUndelete(context);
                case 'editMessage':
                    return await this.onTeamsMessageEdit(context);
                default:
                    return await super.dispatchMessageUpdateActivity(context);
            }
        }
        else {
            return await super.dispatchMessageUpdateActivity(context);
        }
    }
    /**
     * Dispatches message delete activity.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async dispatchMessageDeleteActivity(context) {
        if (context.activity.channelId === 'msteams') {
            const channelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
            switch (channelData.eventType) {
                case 'softDeleteMessage':
                    return await this.onTeamsMessageSoftDelete(context);
                default:
                    return await super.dispatchMessageDeleteActivity(context);
            }
        }
        else {
            return await super.dispatchMessageDeleteActivity(context);
        }
    }
    /**
     * Handles Teams message undelete.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async onTeamsMessageUndelete(context) {
        await this.handle(context, 'TeamsMessageUndelete', this.defaultNextEvent(context));
    }
    /**
     * Handles Teams message edit.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async onTeamsMessageEdit(context) {
        await this.handle(context, 'TeamsMessageEdit', this.defaultNextEvent(context));
    }
    /**
     * Handles Teams message soft delete.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async onTeamsMessageSoftDelete(context) {
        await this.handle(context, 'onTeamsMessageSoftDelete', this.defaultNextEvent(context));
    }
    /**
     * Handles Teams members added.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async onTeamsMembersAdded(context) {
        if ('TeamsMembersAdded' in this.handlers && this.handlers.TeamsMembersAdded.length > 0) {
            if (!context.activity || (context.activity.membersAdded == null)) {
                throw new Error('OnTeamsMemberAdded: context.activity is undefined');
            }
            for (let i = 0; i < context.activity.membersAdded.length; i++) {
                const channelAccount = context.activity.membersAdded[i];
                if ('givenName' in channelAccount ||
                    'surname' in channelAccount ||
                    'email' in channelAccount ||
                    'userPrincipalName' in channelAccount ||
                    ((context.activity.recipient != null) && context.activity.recipient.id === channelAccount.id)) {
                    continue;
                }
                try {
                    context.activity.membersAdded[i] = await teamsConnectorClient_1.TeamsConnectorClient.getMember(context.activity, channelAccount.id);
                }
                catch (err) {
                    const errCode = err.body && err.body.error && err.body.error.code;
                    if (errCode === 'ConversationNotFound') {
                        const teamsChannelAccount = {
                            id: channelAccount.id,
                            name: channelAccount.name,
                            aadObjectId: channelAccount.aadObjectId,
                            role: channelAccount.role
                        };
                        context.activity.membersAdded[i] = teamsChannelAccount;
                    }
                    else {
                        throw err;
                    }
                }
            }
            await this.handle(context, 'TeamsMembersAdded', this.defaultNextEvent(context));
        }
        else {
            await this.handle(context, 'MembersAdded', this.defaultNextEvent(context));
        }
    }
    /**
     * Handles Teams members removed.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async onTeamsMembersRemoved(context) {
        if ('TeamsMembersRemoved' in this.handlers && this.handlers.TeamsMembersRemoved.length > 0) {
            await this.handle(context, 'TeamsMembersRemoved', this.defaultNextEvent(context));
        }
        else {
            await this.handle(context, 'MembersRemoved', this.defaultNextEvent(context));
        }
    }
    /**
     * Handles Teams channel created.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async onTeamsChannelCreated(context) {
        await this.handle(context, 'TeamsChannelCreated', this.defaultNextEvent(context));
    }
    /**
     * Handles Teams channel deleted.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async onTeamsChannelDeleted(context) {
        await this.handle(context, 'TeamsChannelDeleted', this.defaultNextEvent(context));
    }
    /**
     * Handles Teams channel renamed.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async onTeamsChannelRenamed(context) {
        await this.handle(context, 'TeamsChannelRenamed', this.defaultNextEvent(context));
    }
    /**
     * Handles Teams team archived.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async onTeamsTeamArchived(context) {
        await this.handle(context, 'TeamsTeamArchived', this.defaultNextEvent(context));
    }
    /**
     * Handles Teams team deleted.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async onTeamsTeamDeleted(context) {
        await this.handle(context, 'TeamsTeamDeleted', this.defaultNextEvent(context));
    }
    /**
     * Handles Teams team hard deleted.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async onTeamsTeamHardDeleted(context) {
        await this.handle(context, 'TeamsTeamHardDeleted', this.defaultNextEvent(context));
    }
    /**
     * Handles Teams channel restored.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async onTeamsChannelRestored(context) {
        await this.handle(context, 'TeamsChannelRestored', this.defaultNextEvent(context));
    }
    /**
     * Handles Teams team renamed.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async onTeamsTeamRenamed(context) {
        await this.handle(context, 'TeamsTeamRenamed', this.defaultNextEvent(context));
    }
    /**
     * Handles Teams team restored.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async onTeamsTeamRestored(context) {
        await this.handle(context, 'TeamsTeamRestored', this.defaultNextEvent(context));
    }
    /**
     * Handles Teams team unarchived.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async onTeamsTeamUnarchived(context) {
        await this.handle(context, 'TeamsTeamUnarchived', this.defaultNextEvent(context));
    }
    /**
     * Registers a handler for Teams message undelete event.
     * @param {function} handler - The handler function.
     * @returns {this}
     */
    onTeamsMessageUndeleteEvent(handler) {
        return this.on('TeamsMessageUndelete', async (context, next) => {
            await handler(context, next);
        });
    }
    /**
     * Registers a handler for Teams message edit event.
     * @param {function} handler - The handler function.
     * @returns {this}
     */
    onTeamsMessageEditEvent(handler) {
        return this.on('TeamsMessageEdit', async (context, next) => {
            await handler(context, next);
        });
    }
    /**
     * Registers a handler for Teams message soft delete event.
     * @param {function} handler - The handler function.
     * @returns {this}
     */
    onTeamsMessageSoftDeleteEvent(handler) {
        return this.on('onTeamsMessageSoftDelete', async (context, next) => {
            await handler(context, next);
        });
    }
    /**
     * Registers a handler for Teams members added event.
     * @param {function} handler - The handler function.
     * @returns {this}
     */
    onTeamsMembersAddedEvent(handler) {
        return this.on('TeamsMembersAdded', async (context, next) => {
            const teamsChannelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
            await handler(context.activity.membersAdded || [], teamsChannelData.team, context, next);
        });
    }
    /**
     * Registers a handler for Teams members removed event.
     * @param {function} handler - The handler function.
     * @returns {this}
     */
    onTeamsMembersRemovedEvent(handler) {
        return this.on('TeamsMembersRemoved', async (context, next) => {
            const teamsChannelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
            await handler(context.activity.membersRemoved || [], teamsChannelData.team, context, next);
        });
    }
    /**
     * Registers a handler for Teams channel created event.
     * @param {function} handler - The handler function.
     * @returns {this}
     */
    onTeamsChannelCreatedEvent(handler) {
        return this.on('TeamsChannelCreated', async (context, next) => {
            const teamsChannelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
            await handler(teamsChannelData.channel, teamsChannelData.team, context, next);
        });
    }
    /**
     * Registers a handler for Teams channel deleted event.
     * @param {function} handler - The handler function.
     * @returns {this}
     */
    onTeamsChannelDeletedEvent(handler) {
        return this.on('TeamsChannelDeleted', async (context, next) => {
            const teamsChannelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
            await handler(teamsChannelData.channel, teamsChannelData.team, context, next);
        });
    }
    /**
     * Registers a handler for Teams channel renamed event.
     * @param {function} handler - The handler function.
     * @returns {this}
     */
    onTeamsChannelRenamedEvent(handler) {
        return this.on('TeamsChannelRenamed', async (context, next) => {
            const teamsChannelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
            await handler(teamsChannelData.channel, teamsChannelData.team, context, next);
        });
    }
    /**
     * Registers a handler for Teams team archived event.
     * @param {function} handler - The handler function.
     * @returns {this}
     */
    onTeamsTeamArchivedEvent(handler) {
        return this.on('TeamsTeamArchived', async (context, next) => {
            const teamsChannelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
            await handler(teamsChannelData.team, context, next);
        });
    }
    /**
     * Registers a handler for Teams team deleted event.
     * @param {function} handler - The handler function.
     * @returns {this}
     */
    onTeamsTeamDeletedEvent(handler) {
        return this.on('TeamsTeamDeleted', async (context, next) => {
            const teamsChannelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
            await handler(teamsChannelData.team, context, next);
        });
    }
    /**
     * Registers a handler for Teams team hard deleted event.
     * @param {function} handler - The handler function.
     * @returns {this}
     */
    onTeamsTeamHardDeletedEvent(handler) {
        return this.on('TeamsTeamHardDeleted', async (context, next) => {
            const teamsChannelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
            await handler(teamsChannelData.team, context, next);
        });
    }
    /**
     * Registers a handler for Teams channel restored event.
     * @param {function} handler - The handler function.
     * @returns {this}
     */
    onTeamsChannelRestoredEvent(handler) {
        return this.on('TeamsChannelRestored', async (context, next) => {
            const teamsChannelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
            await handler(teamsChannelData.channel, teamsChannelData.team, context, next);
        });
    }
    /**
     * Registers a handler for Teams team renamed event.
     * @param {function} handler - The handler function.
     * @returns {this}
     */
    onTeamsTeamRenamedEvent(handler) {
        return this.on('TeamsTeamRenamed', async (context, next) => {
            const teamsChannelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
            await handler(teamsChannelData.team, context, next);
        });
    }
    /**
     * Registers a handler for Teams team restored event.
     * @param {function} handler - The handler function.
     * @returns {this}
     */
    onTeamsTeamRestoredEvent(handler) {
        return this.on('TeamsTeamRestored', async (context, next) => {
            const teamsChannelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
            await handler(teamsChannelData.team, context, next);
        });
    }
    /**
     * Registers a handler for Teams team unarchived event.
     * @param {function} handler - The handler function.
     * @returns {this}
     */
    onTeamsTeamUnarchivedEvent(handler) {
        return this.on('TeamsTeamUnarchived', async (context, next) => {
            const teamsChannelData = (0, teamsChannelDataParser_1.parseTeamsChannelData)(context.activity.channelData);
            await handler(teamsChannelData.team, context, next);
        });
    }
    /**
     * Dispatches event activity.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async dispatchEventActivity(context) {
        if (context.activity.channelId === agents_activity_1.Channels.Msteams) {
            switch (context.activity.name) {
                case 'application/vnd.microsoft.readReceipt':
                    return await this.onTeamsReadReceipt(context);
                case 'application/vnd.microsoft.meetingStart':
                    return await this.onTeamsMeetingStart(context);
                case 'application/vnd.microsoft.meetingEnd':
                    return await this.onTeamsMeetingEnd(context);
                case 'application/vnd.microsoft.meetingParticipantJoin':
                    return await this.onTeamsMeetingParticipantsJoin(context);
                case 'application/vnd.microsoft.meetingParticipantLeave':
                    return await this.onTeamsMeetingParticipantsLeave(context);
            }
        }
        return await super.dispatchEventActivity(context);
    }
    /**
     * Handles Teams meeting start.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async onTeamsMeetingStart(context) {
        await this.handle(context, 'TeamsMeetingStart', this.defaultNextEvent(context));
    }
    /**
     * Handles Teams meeting end.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async onTeamsMeetingEnd(context) {
        await this.handle(context, 'TeamsMeetingEnd', this.defaultNextEvent(context));
    }
    /**
     * Handles Teams read receipt.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async onTeamsReadReceipt(context) {
        await this.handle(context, 'TeamsReadReceipt', this.defaultNextEvent(context));
    }
    /**
     * Handles Teams meeting participants join.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async onTeamsMeetingParticipantsJoin(context) {
        await this.handle(context, 'TeamsMeetingParticipantsJoin', this.defaultNextEvent(context));
    }
    /**
     * Handles Teams meeting participants leave.
     * @param {TurnContext} context - The context object for the turn.
     * @returns {Promise<void>}
     */
    async onTeamsMeetingParticipantsLeave(context) {
        await this.handle(context, 'TeamsMeetingParticipantsLeave', this.defaultNextEvent(context));
    }
    /**
     * Registers a handler for Teams meeting start event.
     * @param {function} handler - The handler function.
     * @returns {this}
     */
    onTeamsMeetingStartEvent(handler) {
        return this.on('TeamsMeetingStart', async (context, next) => {
            const meeting = TeamsMeetingStartT.parse(context.activity.value);
            await handler({
                id: meeting.Id,
                joinUrl: meeting.JoinUrl,
                meetingType: meeting.MeetingType,
                startTime: new Date(meeting.StartTime),
                title: meeting.Title
            }, context, next);
        });
    }
    /**
     * Registers a handler for Teams meeting end event.
     * @param {function} handler - The handler function.
     * @returns {this}
     */
    onTeamsMeetingEndEvent(handler) {
        return this.on('TeamsMeetingEnd', async (context, next) => {
            const meeting = TeamsMeetingEndT.parse(context.activity.value);
            await handler({
                id: meeting.Id,
                joinUrl: meeting.JoinUrl,
                meetingType: meeting.MeetingType,
                endTime: new Date(meeting.EndTime),
                title: meeting.Title
            }, context, next);
        });
    }
    /**
     * Registers a handler for Teams read receipt event.
     * @param {function} handler - The handler function.
     * @returns {this}
     */
    onTeamsReadReceiptEvent(handler) {
        return this.on('TeamsReadReceipt', async (context, next) => {
            const receiptInfo = context.activity.value;
            await handler(new readReceipInfo_1.ReadReceiptInfo(receiptInfo.lastReadMessageId), context, next);
        });
    }
    /**
     * Registers a handler for Teams meeting participants join event.
     * @param {function} handler - The handler function.
     * @returns {this}
     */
    onTeamsMeetingParticipantsJoinEvent(handler) {
        return this.on('TeamsMeetingParticipantsJoin', async (context, next) => {
            const meeting = TeamsMeetingStartT.parse(context.activity.value);
            await handler({
                members: meeting.members
            }, context, next);
        });
    }
    /**
     * Registers a handler for Teams meeting participants leave event.
     * @param {function} handler - The handler function.
     * @returns {this}
     */
    onTeamsMeetingParticipantsLeaveEvent(handler) {
        return this.on('TeamsMeetingParticipantsLeave', async (context, next) => {
            const meeting = TeamsMeetingEndT.parse(context.activity.value);
            await handler({
                members: meeting.members
            }, context, next);
        });
    }
}
exports.TeamsActivityHandler = TeamsActivityHandler;
//# sourceMappingURL=teamsActivityHandler.js.map