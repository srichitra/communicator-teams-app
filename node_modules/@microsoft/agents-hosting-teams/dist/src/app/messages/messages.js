"use strict";
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Messages = void 0;
const agents_activity_1 = require("@microsoft/agents-activity");
const agents_hosting_1 = require("@microsoft/agents-hosting");
const messageInvokeNames_1 = require("./messageInvokeNames");
/**
 * Handles message-related operations for Teams applications.
 * Provides methods for handling message fetch operations.
 * @template TState Type extending TurnState to be used by the application
 */
class Messages {
    /**
     * Creates a new Messages instance.
     * @param app The TeamsApplication instance to associate with this Messages instance
     */
    constructor(app) {
        this._app = app;
    }
    /**
     * Handles fetch requests for messages in Teams, which typically occur when
     * a message action is invoked.
     *
     * @template TData Type of data expected in the message fetch request
     * @param handler Function to handle the message fetch request
     * @returns The TeamsApplication instance for chaining
     */
    fetch(handler) {
        this._app.addRoute(async (context) => {
            var _a, _b;
            return (((_a = context === null || context === void 0 ? void 0 : context.activity) === null || _a === void 0 ? void 0 : _a.type) === agents_activity_1.ActivityTypes.Invoke &&
                ((_b = context === null || context === void 0 ? void 0 : context.activity) === null || _b === void 0 ? void 0 : _b.name) === messageInvokeNames_1.MessageInvokeNames.FETCH_INVOKE_NAME);
        }, async (context, state) => {
            var _a, _b, _c;
            if (((_a = context === null || context === void 0 ? void 0 : context.activity) === null || _a === void 0 ? void 0 : _a.channelId) === agents_activity_1.Channels.Msteams) {
                const result = await handler(context, state, (_c = (_b = context.activity.value) === null || _b === void 0 ? void 0 : _b.data) !== null && _c !== void 0 ? _c : {});
                if (!context.turnState.get(agents_hosting_1.INVOKE_RESPONSE_KEY)) {
                    let response;
                    if (typeof result === 'string') {
                        response = {
                            task: {
                                type: 'message',
                                value: result
                            }
                        };
                    }
                    else {
                        response = {
                            task: {
                                type: 'continue',
                                value: result
                            }
                        };
                    }
                    await context.sendActivity({
                        value: { body: response, status: 200 },
                        type: agents_activity_1.ActivityTypes.InvokeResponse
                    });
                }
            }
        }, true);
        return this._app;
    }
}
exports.Messages = Messages;
//# sourceMappingURL=messages.js.map