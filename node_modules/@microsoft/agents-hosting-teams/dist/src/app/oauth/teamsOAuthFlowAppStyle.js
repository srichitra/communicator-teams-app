"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeamsOAuthFlowAppStyle = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
const agents_activity_1 = require("@microsoft/agents-activity");
const agents_hosting_1 = require("@microsoft/agents-hosting");
const logger = (0, agents_hosting_1.debug)('agents:teams-oauth-flow-app-style');
class TeamsOAuthFlowAppStyle {
    constructor(storage) {
        this.tokenExchangeId = null;
        this.appState = null;
        this.storage = storage;
    }
    async beginFlow(context, state) {
        await state.load(context, this.storage);
        if (this.appState === null) {
            this.appState = state;
        }
        if (Object.keys(this.appState.sso).length === 0) {
            this.appState.sso.flowStarted = false;
            this.appState.sso.userToken = '';
            this.appState.sso.flowExpires = 0;
            await this.appState.save(context, this.storage);
        }
        if (this.appState.sso.userToken !== '') {
            return this.appState.sso.userToken;
        }
        const adapter = context.adapter;
        const authConfig = context.adapter.authConfig;
        if (authConfig.connectionName === undefined) {
            throw new Error('connectionName is not set in the auth config, review your environment variables');
        }
        const scope = 'https://api.botframework.com';
        const accessToken = await adapter.authProvider.getAccessToken(authConfig, scope);
        this.userTokenClient = new agents_hosting_1.UserTokenClient(accessToken);
        const retVal = '';
        await context.sendActivities([agents_hosting_1.MessageFactory.text('authorizing user'), new agents_activity_1.Activity(agents_activity_1.ActivityTypes.Typing)]);
        const signingResource = await this.userTokenClient.getSignInResource(authConfig.clientId, authConfig.connectionName, context.activity);
        const oCard = agents_hosting_1.CardFactory.oauthCard(authConfig.connectionName, 'Sign in', '', signingResource);
        await context.sendActivity(agents_hosting_1.MessageFactory.attachment(oCard));
        state.sso.flowStarted = true;
        state.sso.flowExpires = Date.now() + 30000;
        await state.save(context, this.storage);
        logger.info('OAuth flow started');
        return retVal;
    }
    async continueFlow(context) {
        var _a, _b, _c, _d;
        if (this.appState.sso.userToken !== '') {
            return '';
        }
        await this.appState.load(context, this.storage);
        if (((_a = this.appState.sso) === null || _a === void 0 ? void 0 : _a.flowExpires) !== 0 && Date.now() > this.appState.sso.flowExpires) {
            logger.warn('Sign-in flow expired');
            this.appState.sso.flowStarted = false;
            this.appState.sso.userToken = '';
            await context.sendActivity(agents_hosting_1.MessageFactory.text('Sign-in session expired. Please try again.'));
            return '';
        }
        const contFlowActivity = context.activity;
        const authConfig = context.adapter.authConfig;
        const tokenExchangeRequest = contFlowActivity.value;
        if (this.tokenExchangeId === tokenExchangeRequest.id) {
            return ''; // dedupe
        }
        this.tokenExchangeId = tokenExchangeRequest.id;
        const userTokenReq = await ((_b = this.userTokenClient) === null || _b === void 0 ? void 0 : _b.exchangeTokenAsync((_c = contFlowActivity.from) === null || _c === void 0 ? void 0 : _c.id, authConfig.connectionName, contFlowActivity.channelId, tokenExchangeRequest));
        if ((userTokenReq === null || userTokenReq === void 0 ? void 0 : userTokenReq.status) === agents_hosting_1.TokenRequestStatus.Success) {
            logger.info('Token obtained');
            // this.appState!.sso!.userToken = userTokenReq.token
            this.appState.sso.flowStarted = false;
            await context.sendActivity(agents_hosting_1.MessageFactory.text('User signed in ' + new Date().toISOString()));
            await this.appState.save(context, this.storage);
            return (_d = this.appState.sso) === null || _d === void 0 ? void 0 : _d.userToken;
        }
    }
    async signOut(context) {
        var _a, _b;
        if (this.appState !== null) {
            await this.appState.load(context, this.storage);
            await ((_a = this.userTokenClient) === null || _a === void 0 ? void 0 : _a.signOut((_b = context.activity.from) === null || _b === void 0 ? void 0 : _b.id, context.adapter.authConfig.connectionName, context.activity.channelId));
            await context.sendActivity(agents_hosting_1.MessageFactory.text('User signed out'));
            this.appState.sso.userToken = '';
            this.appState.sso.flowExpires = 0;
            await this.appState.save(context, this.storage);
            logger.info('User signed out successfully');
        }
        else {
            await context.sendActivity(agents_hosting_1.MessageFactory.text('User is not signed in'));
        }
    }
    async userSignedInToken(context) {
        var _a, _b, _c;
        await ((_a = this.appState) === null || _a === void 0 ? void 0 : _a.load(context, this.storage));
        return (_c = (_b = this.appState) === null || _b === void 0 ? void 0 : _b.sso) === null || _c === void 0 ? void 0 : _c.userToken;
    }
}
exports.TeamsOAuthFlowAppStyle = TeamsOAuthFlowAppStyle;
//# sourceMappingURL=teamsOAuthFlowAppStyle.js.map