"use strict";
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloudAdapter = void 0;
const activityHandler_1 = require("./activityHandler");
const baseAdapter_1 = require("./baseAdapter");
const turnContext_1 = require("./turnContext");
const connectorClient_1 = require("./connector-client/connectorClient");
const agents_activity_1 = require("@microsoft/agents-activity");
const msalTokenProvider_1 = require("./auth/msalTokenProvider");
const uuid = __importStar(require("uuid"));
const logger_1 = require("./logger");
const statusCodes_1 = require("./statusCodes");
const activityWireCompat_1 = require("./activityWireCompat");
const logger = (0, logger_1.debug)('agents:cloud-adapter');
/**
 * Adapter for handling agent interactions with various channels through cloud-based services.
 *
 * CloudAdapter processes incoming HTTP requests from Microsoft Bot Framework channels,
 * authenticates them, and generates outgoing responses. It manages the communication
 * flow between agents and users across different channels, handling activities, attachments,
 * and conversation continuations.
 */
class CloudAdapter extends baseAdapter_1.BaseAdapter {
    /**
     * Creates an instance of CloudAdapter.
     * @param authConfig - The authentication configuration for securing communications
     * @param authProvider - Optional custom authentication provider. If not specified, a default MsalTokenProvider will be used
     */
    constructor(authConfig, authProvider) {
        super();
        this.authConfig = authConfig;
        if (authProvider === undefined) {
            this.authProvider = new msalTokenProvider_1.MsalTokenProvider();
        }
        else {
            this.authProvider = authProvider;
        }
    }
    /**
     * Creates a connector client for a specific service URL and scope.
     *
     * @param serviceUrl - The URL of the service to connect to
     * @param scope - The authentication scope to use
     * @returns A promise that resolves to a ConnectorClient instance
     * @protected
     */
    async createConnectorClient(serviceUrl, scope) {
        return connectorClient_1.ConnectorClient.createClientWithAuthAsync(serviceUrl, this.authConfig, this.authProvider, scope);
    }
    /**
     * Sets the connector client on the turn context.
     *
     * @param context - The current turn context
     * @protected
     */
    setConnectorClient(context) {
        context.turnState.set('connectorClient', this.connectorClient);
    }
    /**
     * Creates a TurnContext for the given activity and logic.
     * @param activity - The activity to process.
     * @param logic - The logic to execute.
     * @returns The created TurnContext.
     */
    createTurnContext(activity, logic) {
        return new turnContext_1.TurnContext(this, activity);
    }
    async createTurnContextWithScope(activity, logic, scope) {
        this.connectorClient = await connectorClient_1.ConnectorClient.createClientWithAuthAsync(activity.serviceUrl, this.authConfig, this.authProvider, scope);
        return new turnContext_1.TurnContext(this, activity);
    }
    /**
     * Sends multiple activities to the conversation.
     * @param context - The TurnContext for the current turn.
     * @param activities - The activities to send.
     * @returns A promise representing the array of ResourceResponses for the sent activities.
     */
    async sendActivities(context, activities) {
        var _a;
        if (!context) {
            throw new TypeError('`context` parameter required');
        }
        if (!activities) {
            throw new TypeError('`activities` parameter required');
        }
        if (activities.length === 0) {
            throw new Error('Expecting one or more activities, but the array was empty.');
        }
        const responses = [];
        for (const activity of activities) {
            delete activity.id;
            let response = { id: '' };
            if (activity.type === agents_activity_1.ActivityTypes.Delay) {
                await setTimeout(() => { }, typeof activity.value === 'number' ? activity.value : 1000);
            }
            else if (activity.type === agents_activity_1.ActivityTypes.InvokeResponse) {
                context.turnState.set(activityHandler_1.INVOKE_RESPONSE_KEY, activity);
            }
            else if (activity.type === agents_activity_1.ActivityTypes.Trace && activity.channelId !== agents_activity_1.Channels.Emulator) {
                // no-op
            }
            else {
                if (!activity.serviceUrl || (activity.conversation == null) || !activity.conversation.id) {
                    throw new Error('Invalid activity object');
                }
                if (activity.replyToId) {
                    response = await this.connectorClient.replyToActivityAsync(activity.conversation.id, activity.replyToId, activity);
                }
                else {
                    response = await this.connectorClient.sendToConversationAsync(activity.conversation.id, activity);
                }
            }
            if (!response) {
                response = { id: (_a = activity.id) !== null && _a !== void 0 ? _a : '' };
            }
            responses.push(response);
        }
        return responses;
    }
    /**
     * Replies to an activity.
     * @param activity - The activity to reply to.
     * @returns A promise representing the ResourceResponse for the sent activity.
     */
    async replyToActivity(activity) {
        if (!activity.serviceUrl || (activity.conversation == null) || !activity.conversation.id || !activity.id) {
            throw new Error('Invalid activity object');
        }
        return await this.connectorClient.replyToActivityAsync(activity.conversation.id, activity.id, activity);
    }
    /**
     * Processes an incoming request and sends the response.
     * @param request - The incoming request.
     * @param res - The response to send.
     * @param logic - The logic to execute.
     */
    async process(request, res, logic) {
        var _a, _b, _c, _d, _e, _f;
        const end = (status, body, isInvokeResponseOrExpectReplies = false) => {
            res.status(status);
            if (isInvokeResponseOrExpectReplies) {
                res.setHeader('content-type', 'application/json');
            }
            if (body) {
                res.send(body);
            }
            res.end();
        };
        if (!request.body) {
            throw new TypeError('`request.body` parameter required, make sure express.json() is used as middleware');
        }
        const incoming = (0, activityWireCompat_1.normalizeIncomingActivity)(request.body);
        const activity = agents_activity_1.Activity.fromObject(incoming);
        logger.info(`--> Processing incoming activity, type:${activity.type} channel:${activity.channelId}`);
        if (!this.isValidChannelActivity(activity)) {
            return end(statusCodes_1.StatusCodes.BAD_REQUEST);
        }
        logger.debug('Received activity: ', activity);
        if ((activity === null || activity === void 0 ? void 0 : activity.type) === agents_activity_1.ActivityTypes.InvokeResponse ||
            (activity === null || activity === void 0 ? void 0 : activity.type) === agents_activity_1.ActivityTypes.Invoke ||
            (activity === null || activity === void 0 ? void 0 : activity.deliveryMode) === agents_activity_1.DeliveryModes.ExpectReplies) {
            const context = this.createTurnContext(activity, logic);
            await this.runMiddleware(context, logic);
            const invokeResponse = this.processTurnResults(context);
            logger.debug('Activity Response (invoke/expect replies): ', invokeResponse);
            return end((_a = invokeResponse === null || invokeResponse === void 0 ? void 0 : invokeResponse.status) !== null && _a !== void 0 ? _a : statusCodes_1.StatusCodes.OK, JSON.stringify(invokeResponse === null || invokeResponse === void 0 ? void 0 : invokeResponse.body), true);
        }
        const scope = (_e = (_c = (_b = request.user) === null || _b === void 0 ? void 0 : _b.azp) !== null && _c !== void 0 ? _c : (_d = request.user) === null || _d === void 0 ? void 0 : _d.appid) !== null && _e !== void 0 ? _e : 'https://api.botframework.com';
        logger.debug('Creating connector client with scope: ', scope);
        this.connectorClient = await this.createConnectorClient(activity.serviceUrl, scope);
        const context = this.createTurnContext(activity, logic);
        this.setConnectorClient(context);
        await this.runMiddleware(context, logic);
        const invokeResponse = this.processTurnResults(context);
        return end((_f = invokeResponse === null || invokeResponse === void 0 ? void 0 : invokeResponse.status) !== null && _f !== void 0 ? _f : statusCodes_1.StatusCodes.OK, invokeResponse === null || invokeResponse === void 0 ? void 0 : invokeResponse.body);
    }
    isValidChannelActivity(activity) {
        var _a, _b;
        if (activity == null) {
            logger.warn('BadRequest: Missing activity');
            return false;
        }
        if (activity.type == null || activity.type === '') {
            logger.warn('BadRequest: Missing activity type');
            return false;
        }
        if (((_a = activity.conversation) === null || _a === void 0 ? void 0 : _a.id) == null || ((_b = activity.conversation) === null || _b === void 0 ? void 0 : _b.id) === '') {
            logger.warn('BadRequest: Missing conversation.Id');
            return false;
        }
        return true;
    }
    /**
     * Updates an activity.
     * @param context - The TurnContext for the current turn.
     * @param activity - The activity to update.
     * @returns A promise representing the ResourceResponse for the updated activity.
     */
    async updateActivity(context, activity) {
        if (!context) {
            throw new TypeError('`context` parameter required');
        }
        if (!activity) {
            throw new TypeError('`activity` parameter required');
        }
        if (!activity.serviceUrl || (activity.conversation == null) || !activity.conversation.id || !activity.id) {
            throw new Error('Invalid activity object');
        }
        const response = await this.connectorClient.updateActivityAsync(activity.conversation.id, activity.id, activity);
        return response.id ? { id: response.id } : undefined;
    }
    /**
     * Deletes an activity.
     * @param context - The TurnContext for the current turn.
     * @param reference - The conversation reference of the activity to delete.
     * @returns A promise representing the completion of the delete operation.
     */
    async deleteActivity(context, reference) {
        if (!context) {
            throw new TypeError('`context` parameter required');
        }
        if (!reference || !reference.serviceUrl || (reference.conversation == null) || !reference.conversation.id || !reference.activityId) {
            throw new Error('Invalid conversation reference object');
        }
        await this.connectorClient.deleteActivityAsync(reference.conversation.id, reference.activityId);
    }
    /**
     * Continues a conversation.
     * @param reference - The conversation reference to continue.
     * @param logic - The logic to execute.
     * @returns A promise representing the completion of the continue operation.
     */
    async continueConversation(reference, logic, isResponse = false) {
        if (!reference || !reference.serviceUrl || (reference.conversation == null) || !reference.conversation.id) {
            throw new Error('Invalid conversation reference object');
        }
        let context;
        if (isResponse) {
            context = await this.createTurnContextWithScope(agents_activity_1.Activity.getContinuationActivity(reference), logic, 'https://api.botframework.com');
        }
        else {
            context = this.createTurnContext(agents_activity_1.Activity.getContinuationActivity(reference), logic);
        }
        await this.runMiddleware(context, logic);
    }
    /**
   * Processes the turn results and returns an InvokeResponse if applicable.
   * @param context - The TurnContext for the current turn.
   * @returns The InvokeResponse if applicable, otherwise undefined.
   */
    processTurnResults(context) {
        logger.info('<--Sending back turn results');
        // Handle ExpectedReplies scenarios where all activities have been buffered and sent back at once in an invoke response.
        if (context.activity.deliveryMode === agents_activity_1.DeliveryModes.ExpectReplies) {
            return {
                status: statusCodes_1.StatusCodes.OK,
                body: {
                    activities: context.bufferedReplyActivities
                }
            };
        }
        // Handle Invoke scenarios where the agent will return a specific body and return code.
        if (context.activity.type === agents_activity_1.ActivityTypes.Invoke) {
            const activityInvokeResponse = context.turnState.get(activityHandler_1.INVOKE_RESPONSE_KEY);
            if (!activityInvokeResponse) {
                return { status: statusCodes_1.StatusCodes.NOT_IMPLEMENTED };
            }
            return activityInvokeResponse.value;
        }
        // No body to return.
        return undefined;
    }
    /**
     * Creates an activity to represent the result of creating a conversation.
     * @param createdConversationId - The ID of the created conversation.
     * @param channelId - The channel ID.
     * @param serviceUrl - The service URL.
     * @param conversationParameters - The conversation parameters.
     * @returns The created activity.
     */
    createCreateActivity(createdConversationId, channelId, serviceUrl, conversationParameters) {
        // Create a conversation update activity to represent the result.
        const activity = new agents_activity_1.Activity(agents_activity_1.ActivityTypes.Event);
        activity.name = agents_activity_1.ActivityEventNames.CreateConversation;
        activity.channelId = channelId;
        activity.serviceUrl = serviceUrl;
        activity.id = createdConversationId !== null && createdConversationId !== void 0 ? createdConversationId : uuid.v4();
        activity.conversation = {
            conversationType: undefined,
            id: createdConversationId,
            isGroup: conversationParameters.isGroup,
            name: undefined,
            tenantId: conversationParameters.tenantId,
        };
        activity.channelData = conversationParameters.channelData;
        activity.recipient = conversationParameters.agent;
        return activity;
    }
    /**
     * Creates a conversation.
     * @param agentAppId - The agent application ID.
     * @param channelId - The channel ID.
     * @param serviceUrl - The service URL.
     * @param audience - The audience.
     * @param conversationParameters - The conversation parameters.
     * @param logic - The logic to execute.
     * @returns A promise representing the completion of the create operation.
     */
    async createConversationAsync(agentAppId, channelId, serviceUrl, audience, conversationParameters, logic) {
        if (typeof serviceUrl !== 'string' || !serviceUrl) {
            throw new TypeError('`serviceUrl` must be a non-empty string');
        }
        if (!conversationParameters)
            throw new TypeError('`conversationParameters` must be defined');
        if (!logic)
            throw new TypeError('`logic` must be defined');
        const restClient = await this.createConnectorClient(serviceUrl, audience);
        const createConversationResult = await restClient.createConversationAsync(conversationParameters);
        const createActivity = this.createCreateActivity(createConversationResult.id, channelId, serviceUrl, conversationParameters);
        const context = new turnContext_1.TurnContext(this, createActivity);
        await this.runMiddleware(context, logic);
    }
    /**
     * Uploads an attachment.
     * @param conversationId - The conversation ID.
     * @param attachmentData - The attachment data.
     * @returns A promise representing the ResourceResponse for the uploaded attachment.
     */
    async uploadAttachment(conversationId, attachmentData) {
        if (conversationId === undefined) {
            throw new Error('conversationId is required');
        }
        if (attachmentData === undefined) {
            throw new Error('attachmentData is required');
        }
        return await this.connectorClient.uploadAttachment(conversationId, attachmentData);
    }
    /**
     * Gets attachment information.
     * @param attachmentId - The attachment ID.
     * @returns A promise representing the AttachmentInfo for the requested attachment.
     */
    async getAttachmentInfo(attachmentId) {
        if (attachmentId === undefined) {
            throw new Error('attachmentId is required');
        }
        return await this.connectorClient.getAttachmentInfo(attachmentId);
    }
    /**
     * Gets an attachment.
     * @param attachmentId - The attachment ID.
     * @param viewId - The view ID.
     * @returns A promise representing the NodeJS.ReadableStream for the requested attachment.
     */
    async getAttachment(attachmentId, viewId) {
        if (attachmentId === undefined) {
            throw new Error('attachmentId is required');
        }
        if (viewId === undefined) {
            throw new Error('viewId is required');
        }
        return await this.connectorClient.getAttachment(attachmentId, viewId);
    }
}
exports.CloudAdapter = CloudAdapter;
//# sourceMappingURL=cloudAdapter.js.map