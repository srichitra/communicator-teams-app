"use strict";
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseAdapter = void 0;
const msalTokenProvider_1 = require("./auth/msalTokenProvider");
const middlewareSet_1 = require("./middlewareSet");
const logger_1 = require("./logger");
const logger = (0, logger_1.debug)('agents:base-adapter');
/**
 * Base class for all adapters, providing middleware and error handling capabilities.
 */
class BaseAdapter {
    constructor() {
        this.middleware = new middlewareSet_1.MiddlewareSet();
        this.turnError = async (context, error) => {
            logger.error(`\n [onTurnError] unhandled error: ${error}`);
            // Send a trace activity, which will be displayed in Bot Framework Emulator
            await context.sendTraceActivity('OnTurnError Trace', `${error}`, 'https://www.botframework.com/schemas/error', 'TurnError');
            // Send a message to the user
            await context.sendActivity('The agent encountered an error or bug.');
            await context.sendActivity('To continue to run this agent, please fix the source code.');
        };
        this.AgentIdentityKey = Symbol('AgentIdentity');
        this.ConnectorClientKey = Symbol('ConnectorClient');
        this.OAuthScopeKey = Symbol('OAuthScope');
        this.authProvider = new msalTokenProvider_1.MsalTokenProvider();
        this.authConfig = { issuers: [] };
    }
    get onTurnError() {
        return this.turnError;
    }
    set onTurnError(value) {
        this.turnError = value;
    }
    /**
     * Adds middleware to the adapter's middleware pipeline.
     * @param middlewares - The middleware to add.
     * @returns The adapter instance.
     */
    use(...middlewares) {
        this.middleware.use(...middlewares);
        return this;
    }
    makeRevocable(target, handler) {
        // Ensure proxy supported (some browsers don't)
        if (typeof Proxy !== 'undefined' && Proxy.revocable) {
            return Proxy.revocable(target, (handler != null) ? handler : {});
        }
        else {
            return {
                proxy: target,
                revoke: () => {
                    // noop
                }
            };
        }
    }
    /**
     * Runs the middleware pipeline in sequence.
     * @param context - The TurnContext for the current turn.
     * @param next - The next function to call in the pipeline.
     * @returns A promise representing the completion of the middleware pipeline.
     */
    async runMiddleware(context, next) {
        if (context && context.activity && context.activity.locale) {
            context.locale = context.activity.locale;
        }
        const pContext = this.makeRevocable(context);
        try {
            await this.middleware.run(pContext.proxy, async () => await next(pContext.proxy));
        }
        catch (err) {
            if (this.onTurnError) {
                if (err instanceof Error) {
                    await this.onTurnError(pContext.proxy, err);
                }
                else {
                    throw new Error('Unknown error type');
                }
            }
            else {
                throw err;
            }
        }
        finally {
            pContext.revoke();
        }
    }
}
exports.BaseAdapter = BaseAdapter;
//# sourceMappingURL=baseAdapter.js.map