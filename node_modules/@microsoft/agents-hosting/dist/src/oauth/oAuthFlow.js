"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OAuthFlow = exports.FlowState = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
const logger_1 = require("./../logger");
const agents_activity_1 = require("@microsoft/agents-activity");
const __1 = require("../");
const tokenResponse_1 = require("./tokenResponse");
const logger = (0, logger_1.debug)('agents:oauth-flow');
class FlowState {
    constructor() {
        this.flowStarted = false;
        this.flowExpires = 0;
    }
}
exports.FlowState = FlowState;
/**
 * Manages the OAuth flow for Teams.
 */
class OAuthFlow {
    /**
     * Creates a new instance of OAuthFlow.
     * @param userState The user state.
     */
    constructor(userState, absOauthConnectionName, tokenClient) {
        this.tokenExchangeId = null;
        this.state = null;
        this.flowStateAccessor = userState.createProperty('flowState');
        this.absOauthConnectionName = absOauthConnectionName;
        this.userTokenClient = tokenClient;
    }
    async getUserToken(context) {
        var _a, _b;
        await this.initializeTokenClient(context);
        return await ((_a = this.userTokenClient) === null || _a === void 0 ? void 0 : _a.getUserToken(this.absOauthConnectionName, context.activity.channelId, (_b = context.activity.from) === null || _b === void 0 ? void 0 : _b.id));
    }
    /**
     * Begins the OAuth flow.
     * @param context The turn context.
     * @returns A promise that resolves to the user token.
     */
    async beginFlow(context) {
        var _a;
        logger.info('Starting OAuth flow');
        this.state = await this.getUserState(context);
        const authConfig = context.adapter.authConfig;
        if (this.absOauthConnectionName === '') {
            throw new Error('connectionName is not set in the auth config, review your environment variables');
        }
        await this.initializeTokenClient(context);
        const tokenResponse = await this.userTokenClient.getUserToken(this.absOauthConnectionName, context.activity.channelId, (_a = context.activity.from) === null || _a === void 0 ? void 0 : _a.id);
        if ((tokenResponse === null || tokenResponse === void 0 ? void 0 : tokenResponse.status) === tokenResponse_1.TokenRequestStatus.Success) {
            this.state.flowStarted = false;
            this.state.flowExpires = 0;
            await this.flowStateAccessor.set(context, this.state);
            logger.info('User token retrieved successfully from service');
            return tokenResponse;
        }
        const signingResource = await this.userTokenClient.getSignInResource(authConfig.clientId, this.absOauthConnectionName, context.activity);
        const oCard = __1.CardFactory.oauthCard(this.absOauthConnectionName, 'Sign in', 'login', signingResource);
        const cardActivity = __1.MessageFactory.attachment(oCard);
        await context.sendActivity(cardActivity);
        this.state.flowStarted = true;
        this.state.flowExpires = Date.now() + 30000;
        await this.flowStateAccessor.set(context, this.state);
        logger.info('OAuth begin flow completed, waiting for user to sign in');
        return {
            token: undefined,
            status: tokenResponse_1.TokenRequestStatus.InProgress
        };
    }
    /**
     * Continues the OAuth flow.
     * @param context The turn context.
     * @returns A promise that resolves to the user token.
     */
    async continueFlow(context) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.state = await this.getUserState(context);
        await this.initializeTokenClient(context);
        if (((_a = this.state) === null || _a === void 0 ? void 0 : _a.flowExpires) !== 0 && Date.now() > this.state.flowExpires) {
            logger.warn('Flow expired');
            this.state.flowStarted = false;
            await context.sendActivity(__1.MessageFactory.text('Sign-in session expired. Please try again.'));
            return { status: tokenResponse_1.TokenRequestStatus.Expired, token: undefined };
        }
        const contFlowActivity = context.activity;
        if (contFlowActivity.type === agents_activity_1.ActivityTypes.Message) {
            const magicCode = contFlowActivity.text;
            const result = await ((_b = this.userTokenClient) === null || _b === void 0 ? void 0 : _b.getUserToken(this.absOauthConnectionName, contFlowActivity.channelId, (_c = contFlowActivity.from) === null || _c === void 0 ? void 0 : _c.id, magicCode));
            return result;
        }
        if (contFlowActivity.type === agents_activity_1.ActivityTypes.Invoke && contFlowActivity.name === 'signin/verifyState') {
            logger.info('Continuing OAuth flow with verifyState');
            const tokenVerifyState = contFlowActivity.value;
            const magicCode = tokenVerifyState.state;
            const result = await ((_d = this.userTokenClient) === null || _d === void 0 ? void 0 : _d.getUserToken(this.absOauthConnectionName, contFlowActivity.channelId, (_e = contFlowActivity.from) === null || _e === void 0 ? void 0 : _e.id, magicCode));
            return result;
        }
        if (contFlowActivity.type === agents_activity_1.ActivityTypes.Invoke && contFlowActivity.name === 'signin/tokenExchange') {
            logger.info('Continuing OAuth flow with tokenExchange');
            const tokenExchangeRequest = contFlowActivity.value;
            if (this.tokenExchangeId === tokenExchangeRequest.id) { // dedupe
                return { status: tokenResponse_1.TokenRequestStatus.InProgress, token: undefined };
            }
            this.tokenExchangeId = tokenExchangeRequest.id;
            const userTokenResp = await ((_f = this.userTokenClient) === null || _f === void 0 ? void 0 : _f.exchangeTokenAsync((_g = contFlowActivity.from) === null || _g === void 0 ? void 0 : _g.id, this.absOauthConnectionName, contFlowActivity.channelId, tokenExchangeRequest));
            if ((userTokenResp === null || userTokenResp === void 0 ? void 0 : userTokenResp.status) === tokenResponse_1.TokenRequestStatus.Success) {
                logger.info('Token exchanged');
                this.state.flowStarted = false;
                await this.flowStateAccessor.set(context, this.state);
                return userTokenResp;
            }
            else {
                logger.warn('Token exchange failed');
                this.state.flowStarted = true;
                return { status: tokenResponse_1.TokenRequestStatus.Failed, token: undefined };
            }
        }
        return { status: tokenResponse_1.TokenRequestStatus.Failed, token: undefined };
    }
    /**
     * Signs the user out.
     * @param context The turn context.
     * @returns A promise that resolves when the sign-out operation is complete.
     */
    async signOut(context) {
        var _a, _b;
        this.state = await this.getUserState(context);
        await this.initializeTokenClient(context);
        await ((_a = this.userTokenClient) === null || _a === void 0 ? void 0 : _a.signOut((_b = context.activity.from) === null || _b === void 0 ? void 0 : _b.id, this.absOauthConnectionName, context.activity.channelId));
        this.state.flowExpires = 0;
        await this.flowStateAccessor.set(context, this.state);
        logger.info('User signed out successfully');
    }
    /**
     * Gets the user state.
     * @param context The turn context.
     * @returns A promise that resolves to the user state.
     */
    async getUserState(context) {
        let userProfile = await this.flowStateAccessor.get(context, null);
        if (userProfile === null) {
            userProfile = new FlowState();
        }
        return userProfile;
    }
    async initializeTokenClient(context) {
        if (this.userTokenClient === undefined) {
            const scope = 'https://api.botframework.com';
            const accessToken = await context.adapter.authProvider.getAccessToken(context.adapter.authConfig, scope);
            this.userTokenClient = new __1.UserTokenClient(accessToken);
        }
    }
}
exports.OAuthFlow = OAuthFlow;
//# sourceMappingURL=oAuthFlow.js.map