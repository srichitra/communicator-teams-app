/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
import { Activity, ConversationReference } from '@microsoft/agents-activity';
import { TurnState } from './turnState';
import { BaseAdapter } from '../baseAdapter';
import { AgentApplicationOptions } from './agentApplicationOptions';
import { RouteSelector } from './routeSelector';
import { RouteHandler } from './routeHandler';
import { ConversationUpdateEvents } from './conversationUpdateEvents';
import { TurnEvents } from './turnEvents';
import { AppRoute } from './appRoute';
import { TurnContext } from '../turnContext';
import { ResourceResponse } from '../connector-client';
import { UserIdentity } from './oauth/userIdentity';
export type ApplicationEventHandler<TState extends TurnState> = (context: TurnContext, state: TState) => Promise<boolean>;
/**
 * Executes the application logic for a given turn context.
 *
 * @param turnContext - The context for the current turn of the conversation.
 * @returns A promise that resolves when the application logic has completed.
 *
 * @remarks
 * This method is the entry point for processing a turn in the conversation.
 * It delegates the actual processing to the `runInternal` method, which handles
 * the core logic for routing and executing handlers.
 *
 * Example usage:
 * ```typescript
 * const app = new AgentApplication();
 * await app.run(turnContext);
 * ```
 */
export declare class AgentApplication<TState extends TurnState> {
    protected readonly _options: AgentApplicationOptions<TState>;
    protected readonly _routes: AppRoute<TState>[];
    protected readonly _beforeTurn: ApplicationEventHandler<TState>[];
    protected readonly _afterTurn: ApplicationEventHandler<TState>[];
    private readonly _adapter?;
    private _typingTimer;
    private readonly _userIdentity?;
    constructor(options?: Partial<AgentApplicationOptions<TState>>);
    get adapter(): BaseAdapter;
    get userIdentity(): UserIdentity;
    get options(): AgentApplicationOptions<TState>;
    /**
     * Sets an error handler for the application.
     *
     * @param handler - The error handler function to be called when an error occurs.
     * @returns The current instance of the application.
     *
     * @remarks
     * This method allows you to handle any errors that occur during turn processing.
     * The handler will receive the turn context and the error that occurred.
     *
     * Example usage:
     * ```typescript
     * app.error(async (context, error) => {
     *   console.error(`An error occurred: ${error.message}`);
     *   await context.sendActivity('Sorry, something went wrong!');
     * });
     * ```
     */
    error(handler: (context: TurnContext, error: Error) => Promise<void>): this;
    /**
     * Adds a new route to the application for handling activities.
     *
     * @param selector - The selector function that determines if a route should handle the current activity.
     * @param handler - The handler function that will be called if the selector returns true.
     * @returns The current instance of the application.
     *
     * @remarks
     * Routes are evaluated in the order they are added. The first route with a selector that returns true will be used.
     *
     * Example usage:
     * ```typescript
     * app.addRoute(
     *   async (context) => context.activity.type === ActivityTypes.Message,
     *   async (context, state) => {
     *     await context.sendActivity('I received your message');
     *   }
     * );
     * ```
     */
    addRoute(selector: RouteSelector, handler: RouteHandler<TState>): this;
    /**
     * Adds a handler for specific activity types.
     *
     * @param type - The activity type(s) to handle. Can be a string, RegExp, RouteSelector, or array of these types.
     * @param handler - The handler function that will be called when the specified activity type is received.
     * @returns The current instance of the application.
     *
     * @remarks
     * This method allows you to register handlers for specific activity types such as 'message', 'conversationUpdate', etc.
     * You can specify multiple activity types by passing an array.
     *
     * Example usage:
     * ```typescript
     * app.activity(ActivityTypes.Message, async (context, state) => {
     *   await context.sendActivity('I received your message');
     * });
     * ```
     */
    activity(type: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState) => Promise<void>): this;
    /**
     * Adds a handler for conversation update events.
     *
     * @param event - The conversation update event to handle (e.g., 'membersAdded', 'membersRemoved').
     * @param handler - The handler function that will be called when the specified event occurs.
     * @returns The current instance of the application.
     * @throws Error if the handler is not a function.
     *
     * @remarks
     * Conversation update events occur when the state of a conversation changes, such as when members join or leave.
     *
     * Example usage:
     * ```typescript
     * app.conversationUpdate('membersAdded', async (context, state) => {
     *   const membersAdded = context.activity.membersAdded;
     *   for (const member of membersAdded) {
     *     if (member.id !== context.activity.recipient.id) {
     *       await context.sendActivity('Hello and welcome!');
     *     }
     *   }
     * });
     * ```
     */
    conversationUpdate(event: ConversationUpdateEvents, handler: (context: TurnContext, state: TState) => Promise<void>): this;
    /**
     * Continues a conversation asynchronously.
     * @param conversationReferenceOrContext - The conversation reference or turn context.
     * @param logic - The logic to execute during the conversation.
     * @returns A promise that resolves when the conversation logic has completed.
     * @throws Error if the adapter is not configured.
     */
    protected continueConversationAsync(conversationReferenceOrContext: ConversationReference | TurnContext, logic: (context: TurnContext) => Promise<void>): Promise<void>;
    /**
     * Adds a handler for message activities that match the specified keyword or pattern.
     *
     * @param keyword - The keyword, pattern, or selector function to match against message text.
     *                  Can be a string, RegExp, RouteSelector, or array of these types.
     * @param handler - The handler function that will be called when a matching message is received.
     * @returns The current instance of the application.
     *
     * @remarks
     * This method allows you to register handlers for specific message patterns.
     * If keyword is a string, it matches messages containing that string.
     * If keyword is a RegExp, it tests the message text against the regular expression.
     * If keyword is a function, it calls the function with the context to determine if the message matches.
     *
     * Example usage:
     * ```typescript
     * app.message('hello', async (context, state) => {
     *   await context.sendActivity('Hello there!');
     * });
     *
     * app.message(/help., async (context, state) => {
     *   await context.sendActivity('How can I help you?');
     * });
     * ```
     */
    message(keyword: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState) => Promise<void>): this;
    /**
     * Sets a handler to be called when a user successfully signs in.
     *
     * @param handler - The handler function to be called after successful sign-in.
     * @returns The current instance of the application.
     * @throws Error if authentication options were not configured.
     *
     * @remarks
     * This method allows you to perform actions after a user has successfully authenticated.
     * The handler will receive the turn context and state.
     *
     * Example usage:
     * ```typescript
     * app.onSignInSuccess(async (context, state) => {
     *   await context.sendActivity('You have successfully signed in!');
     * });
     * ```
     */
    onSignInSuccess(handler: (context: TurnContext, state: TurnState) => void): this;
    /**
     * Executes the application logic for a given turn context.
     *
     * @param turnContext - The context for the current turn of the conversation.
     * @returns A promise that resolves when the application logic has completed.
     *
     * @remarks
     * This method is the entry point for processing a turn in the conversation.
     * It delegates the actual processing to the `runInternal` method, which handles
     * the core logic for routing and executing handlers.
     *
     * Example usage:
     * ```typescript
     * const app = new AgentApplication();
     * await app.run(turnContext);
     * ```
     */
    run(turnContext: TurnContext): Promise<void>;
    /**
     * Executes the application logic for a given turn context.
     * @private
     * @param turnContext - The context for the current turn of the conversation.
     * @returns A promise that resolves to true if a handler was executed, false otherwise.
     *
     * @remarks
     * This method is the core logic for processing a turn in the conversation.
     * It handles routing and executing handlers based on the activity type and content.
     */
    runInternal(turnContext: TurnContext): Promise<boolean>;
    /**
     * Sends a proactive message to a conversation.
     *
     * @param context - The turn context or conversation reference to use.
     * @param activityOrText - The activity or text to send.
     * @param speak - Optional text to be spoken by the bot on a speech-enabled channel.
     * @param inputHint - Optional input hint for the activity.
     * @returns A promise that resolves to the resource response from sending the activity.
     *
     * @remarks
     * This method allows you to send messages proactively to a conversation, outside the normal turn flow.
     *
     * Example usage:
     * ```typescript
     * // With conversation reference
     * await app.sendProactiveActivity(conversationReference, 'Important notification!');
     *
     * // From an existing context
     * await app.sendProactiveActivity(turnContext, 'Important notification!');
     * ```
     */
    sendProactiveActivity(context: TurnContext | ConversationReference, activityOrText: string | Activity, speak?: string, inputHint?: string): Promise<ResourceResponse | undefined>;
    /**
     * Starts a typing indicator timer for the current turn context.
     *
     * @param context - The turn context for the current conversation.
     * @returns void
     *
     * @remarks
     * This method starts a timer that sends typing activity indicators to the user
     * at regular intervals. The typing indicator continues until a message is sent
     * or the timer is explicitly stopped.
     *
     * The typing indicator helps provide feedback to users that the agent is processing
     * their message, especially when responses might take time to generate.
     *
     * Example usage:
     * ```typescript
     * app.startTypingTimer(turnContext);
     * // Do some processing...
     * await turnContext.sendActivity('Response after processing');
     * // Typing timer automatically stops when sending a message
     * ```
     */
    startTypingTimer(context: TurnContext): void;
    /**
     * Stops the typing indicator timer if it's currently running.
     *
     * @returns void
     *
     * @remarks
     * This method clears the typing indicator timer to prevent further typing indicators
     * from being sent. It's typically called automatically when a message is sent, but
     * can also be called manually to stop the typing indicator.
     *
     * Example usage:
     * ```typescript
     * app.startTypingTimer(turnContext);
     * // Do some processing...
     * app.stopTypingTimer(); // Manually stop the typing indicator
     * ```
     */
    stopTypingTimer(): void;
    /**
     * Adds an event handler for specified turn events.
     *
     * @param event - The turn event(s) to handle. Can be 'beforeTurn', 'afterTurn', or other custom events.
     * @param handler - The handler function that will be called when the event occurs.
     * @returns The current instance of the application.
     *
     * @remarks
     * Turn events allow you to execute logic before or after the main turn processing.
     * Handlers added for 'beforeTurn' are executed before routing logic.
     * Handlers added for 'afterTurn' are executed after routing logic.
     *
     * Example usage:
     * ```typescript
     * app.turn('beforeTurn', async (context, state) => {
     *   console.log('Processing before turn');
     *   return true; // Continue execution
     * });
     * ```
     */
    turn(event: TurnEvents | TurnEvents[], handler: (context: TurnContext, state: TState) => Promise<boolean>): this;
    protected callEventHandlers(context: TurnContext, state: TState, handlers: ApplicationEventHandler<TState>[]): Promise<boolean>;
    protected startLongRunningCall(context: TurnContext, handler: (context: TurnContext) => Promise<boolean>): Promise<boolean>;
    private createActivitySelector;
    private createConversationUpdateSelector;
    private createMessageSelector;
}
