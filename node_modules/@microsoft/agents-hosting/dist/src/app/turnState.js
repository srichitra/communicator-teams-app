"use strict";
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TurnState = void 0;
const turnStateEntry_1 = require("./turnStateEntry");
const logger_1 = require("../logger");
const logger = (0, logger_1.debug)('agents:turnState');
const CONVERSATION_SCOPE = 'conversation';
const USER_SCOPE = 'user';
const TEMP_SCOPE = 'temp';
const SSO_SCOPE = 'sso';
/**
 * Base class defining a collection of turn state scopes.
 * @remarks
 * Developers can create a derived class that extends `TurnState` to add additional state scopes.
 * ```JavaScript
 * class MyTurnState extends TurnState {
 *   protected async onComputeStorageKeys(context) {
 *     const keys = await super.onComputeStorageKeys(context);
 *     keys['myScope'] = `myScopeKey`;
 *     return keys;
 *   }
 *
 *   public get myScope() {
 *     const scope = this.getScope('myScope');
 *     if (!scope) {
 *       throw new Error(`MyTurnState hasn't been loaded. Call load() first.`);
 *     }
 *     return scope.value;
 *   }
 *
 *   public set myScope(value) {
 *     const scope = this.getScope('myScope');
 *     if (!scope) {
 *       throw new Error(`MyTurnState hasn't been loaded. Call load() first.`);
 *     }
 *     scope.replace(value);
 *   }
 * }
 * ```
 */
class TurnState {
    constructor() {
        this._scopes = {};
        this._isLoaded = false;
        this._stateNotLoadedString = 'TurnState hasn\'t been loaded. Call load() first.';
    }
    get conversation() {
        const scope = this.getScope(CONVERSATION_SCOPE);
        if (!scope) {
            throw new Error(this._stateNotLoadedString);
        }
        return scope.value;
    }
    set conversation(value) {
        const scope = this.getScope(CONVERSATION_SCOPE);
        if (!scope) {
            throw new Error(this._stateNotLoadedString);
        }
        scope.replace(value);
    }
    get isLoaded() {
        return this._isLoaded;
    }
    get temp() {
        const scope = this.getScope(TEMP_SCOPE);
        if (!scope) {
            throw new Error(this._stateNotLoadedString);
        }
        return scope.value;
    }
    set temp(value) {
        const scope = this.getScope(TEMP_SCOPE);
        if (!scope) {
            throw new Error(this._stateNotLoadedString);
        }
        scope.replace(value);
    }
    get user() {
        const scope = this.getScope(USER_SCOPE);
        if (!scope) {
            throw new Error(this._stateNotLoadedString);
        }
        return scope.value;
    }
    set user(value) {
        const scope = this.getScope(USER_SCOPE);
        if (!scope) {
            throw new Error(this._stateNotLoadedString);
        }
        scope.replace(value);
    }
    get sso() {
        const scope = this.getScope(SSO_SCOPE);
        if (!scope) {
            throw new Error(this._stateNotLoadedString);
        }
        return scope.value;
    }
    set sso(value) {
        const scope = this.getScope(SSO_SCOPE);
        if (!scope) {
            throw new Error(this._stateNotLoadedString);
        }
        scope.replace(value);
    }
    deleteConversationState() {
        const scope = this.getScope(CONVERSATION_SCOPE);
        if (!scope) {
            throw new Error(this._stateNotLoadedString);
        }
        scope.delete();
    }
    deleteTempState() {
        const scope = this.getScope(TEMP_SCOPE);
        if (!scope) {
            throw new Error(this._stateNotLoadedString);
        }
        scope.delete();
    }
    deleteUserState() {
        const scope = this.getScope(USER_SCOPE);
        if (!scope) {
            throw new Error(this._stateNotLoadedString);
        }
        scope.delete();
    }
    getScope(scope) {
        return this._scopes[scope];
    }
    deleteValue(path) {
        const { scope, name } = this.getScopeAndName(path);
        if (Object.prototype.hasOwnProperty.call(scope.value, name)) {
            delete scope.value[name];
        }
    }
    hasValue(path) {
        const { scope, name } = this.getScopeAndName(path);
        return Object.prototype.hasOwnProperty.call(scope.value, name);
    }
    getValue(path) {
        const { scope, name } = this.getScopeAndName(path);
        return scope.value[name];
    }
    setValue(path, value) {
        const { scope, name } = this.getScopeAndName(path);
        scope.value[name] = value;
    }
    load(context, storage, force = false) {
        if (this._isLoaded && !force) {
            return Promise.resolve(false);
        }
        if (!this._loadingPromise) {
            this._loadingPromise = new Promise((resolve, reject) => {
                this._isLoaded = true;
                const keys = [];
                this.onComputeStorageKeys(context)
                    .then(async (scopes) => {
                    for (const key in scopes) {
                        if (Object.prototype.hasOwnProperty.call(scopes, key)) {
                            keys.push(scopes[key]);
                        }
                    }
                    const items = storage ? await storage.read(keys) : {};
                    for (const key in scopes) {
                        if (Object.prototype.hasOwnProperty.call(scopes, key)) {
                            const storageKey = scopes[key];
                            const value = items[storageKey];
                            this._scopes[key] = new turnStateEntry_1.TurnStateEntry(value, storageKey);
                        }
                    }
                    this._scopes[TEMP_SCOPE] = new turnStateEntry_1.TurnStateEntry({});
                    this._isLoaded = true;
                    this._loadingPromise = undefined;
                    resolve(true);
                })
                    .catch((err) => {
                    logger.error(err);
                    this._loadingPromise = undefined;
                    reject(err);
                });
            });
        }
        return this._loadingPromise;
    }
    async save(context, storage) {
        if (!this._isLoaded && this._loadingPromise) {
            await this._loadingPromise;
        }
        if (!this._isLoaded) {
            throw new Error(this._stateNotLoadedString);
        }
        let changes;
        let deletions;
        for (const key in this._scopes) {
            if (!Object.prototype.hasOwnProperty.call(this._scopes, key)) {
                continue;
            }
            const entry = this._scopes[key];
            if (entry.storageKey) {
                if (entry.isDeleted) {
                    if (deletions) {
                        deletions.push(entry.storageKey);
                    }
                    else {
                        deletions = [entry.storageKey];
                    }
                }
                else if (entry.hasChanged) {
                    if (!changes) {
                        changes = {};
                    }
                    changes[entry.storageKey] = entry.value;
                }
            }
        }
        if (storage) {
            const promises = [];
            if (changes) {
                promises.push(storage.write(changes));
            }
            if (deletions) {
                promises.push(storage.delete(deletions));
            }
            if (promises.length > 0) {
                await Promise.all(promises);
            }
        }
    }
    onComputeStorageKeys(context) {
        var _a, _b, _c;
        const activity = context.activity;
        const channelId = activity === null || activity === void 0 ? void 0 : activity.channelId;
        const agentId = (_a = activity === null || activity === void 0 ? void 0 : activity.recipient) === null || _a === void 0 ? void 0 : _a.id;
        const conversationId = (_b = activity === null || activity === void 0 ? void 0 : activity.conversation) === null || _b === void 0 ? void 0 : _b.id;
        const userId = (_c = activity === null || activity === void 0 ? void 0 : activity.from) === null || _c === void 0 ? void 0 : _c.id;
        if (!channelId) {
            throw new Error('missing context.activity.channelId');
        }
        if (!agentId) {
            throw new Error('missing context.activity.recipient.id');
        }
        if (!conversationId) {
            throw new Error('missing context.activity.conversation.id');
        }
        if (!userId) {
            throw new Error('missing context.activity.from.id');
        }
        const keys = {};
        keys[CONVERSATION_SCOPE] = `${channelId}/${agentId}/conversations/${conversationId}`;
        keys[USER_SCOPE] = `${channelId}/${agentId}/users/${userId}`;
        keys[SSO_SCOPE] = `${channelId}/${agentId}/sso`;
        return Promise.resolve(keys);
    }
    getScopeAndName(path) {
        const parts = path.split('.');
        if (parts.length > 2) {
            throw new Error(`Invalid state path: ${path}`);
        }
        else if (parts.length === 1) {
            parts.unshift(TEMP_SCOPE);
        }
        const scope = this.getScope(parts[0]);
        if (scope === undefined) {
            throw new Error(`Invalid state scope: ${parts[0]}`);
        }
        return { scope, name: parts[1] };
    }
}
exports.TurnState = TurnState;
//# sourceMappingURL=turnState.js.map